const e=[{id:"1.1",chapter:"1",number:"1-1",text_en:"The ________ model is the basis for today's computers.",text_zh:"________ 模型是今日電腦的基礎。",options:[{key:"a",text_en:"Charles Babbage",text_zh:"查爾斯·巴貝奇"},{key:"b",text_en:"von Neumann",text_zh:"馮·諾伊曼"},{key:"c",text_en:"Pascal",text_zh:"帕斯卡"},{key:"d",text_en:"Leibnitz",text_zh:"萊布尼茲"}],answer:"b",explanation_zh:"馮·諾伊曼模型（von Neumann model）是現代電腦的基礎，其核心思想是將程式與資料儲存在同一個記憶體中，並依序執行指令。"},{id:"1.2",chapter:"1",number:"1-2",text_en:"In a computer, the ________ subsystem stores data and programs.",text_zh:"在電腦中，________ 子系統儲存資料和程式。",options:[{key:"a",text_en:"control unit",text_zh:"控制單元"},{key:"b",text_en:"input/output",text_zh:"輸入/輸出"},{key:"c",text_en:"memory",text_zh:"記憶體"},{key:"d",text_en:"ALU",text_zh:"算術邏輯單元"}],answer:"c",explanation_zh:"電腦的五大單元中，記憶體（memory）子系統負責儲存資料和程式。"},{id:"1.3",chapter:"1",number:"1-3",text_en:"In a computer, the ________ subsystem performs calculations and logical operations.",text_zh:"在電腦中，________ 子系統執行計算和邏輯運算。",options:[{key:"a",text_en:"control unit",text_zh:"控制單元"},{key:"b",text_en:"input/output",text_zh:"輸入/輸出"},{key:"c",text_en:"memory",text_zh:"記憶體"},{key:"d",text_en:"ALU",text_zh:"算術邏輯單元"}],answer:"d",explanation_zh:"算術邏輯單元（Arithmetic Logic Unit, ALU）是中央處理器（CPU）的一部分，專門負責執行算術運算（如加減）與邏輯運算（如 AND, OR）。"},{id:"1.4",chapter:"1",number:"1-4",text_en:"In a computer, the ________ subsystem accepts data and programs and sends processing results to output devices.",text_zh:"在電腦中，________ 子系統接收資料和程式，並將處理結果發送到輸出設備。",options:[{key:"a",text_en:"control unit",text_zh:"控制單元"},{key:"b",text_en:"input/output",text_zh:"輸入/輸出"},{key:"c",text_en:"memory",text_zh:"記憶體"},{key:"d",text_en:"ALU",text_zh:"算術邏輯單元"}],answer:"b",explanation_zh:"輸入/輸出（input/output）子系統負責電腦與外部世界的溝通，接收來自鍵盤、滑鼠等的輸入，並將結果輸出到螢幕、印表機等設備。"},{id:"1.5",chapter:"1",number:"1-5",text_en:"In a computer, the ________ subsystem serves as a manager of the other subsystems.",text_zh:"在電腦中，________ 子系統擔任其他子系統的管理員。",options:[{key:"a",text_en:"control unit",text_zh:"控制單元"},{key:"b",text_en:"input/output",text_zh:"輸入/輸出"},{key:"c",text_en:"memory",text_zh:"記憶體"},{key:"d",text_en:"ALU",text_zh:"算術邏輯單元"}],answer:"a",explanation_zh:"控制單元（Control Unit）是 CPU 的一部分，負責協調和管理電腦所有子系統的運作，如同電腦的大腦指揮官。"},{id:"1.6",chapter:"1",number:"1-6",text_en:"According to the von Neumann model, ________ are stored in memory.",text_zh:"根據馮·諾伊曼模型，________ 被儲存在記憶體中。",options:[{key:"a",text_en:"data and programs",text_zh:"資料和程式"},{key:"b",text_en:"only programs",text_zh:"只有程式"},{key:"c",text_en:"neither data nor programs",text_zh:"資料和程式皆無"},{key:"d",text_en:"only data",text_zh:"只有資料"}],answer:"a",explanation_zh:"馮·諾伊曼模型的一個關鍵特點是程式和資料都以二進位形式儲存在同一個記憶體中。"},{id:"1.7",chapter:"1",number:"1-7",text_en:"A step-by-step solution to a problem is called ________.",text_zh:"解決問題的逐步方案稱為 ________。",options:[{key:"a",text_en:"an algorithm",text_zh:"演算法"},{key:"b",text_en:"an operating system",text_zh:"作業系統"},{key:"c",text_en:"a computer language",text_zh:"電腦語言"},{key:"d",text_en:"hardware",text_zh:"硬體"}],answer:"a",explanation_zh:"演算法（algorithm）是為了解決特定問題而設計的一系列明確、有限的步驟。它是程式設計的基礎。"},{id:"1.8",chapter:"1",number:"1-8",text_en:"FORTRAN and COBOL are examples of ________.",text_zh:"FORTRAN 和 COBOL 是 ________ 的例子。",options:[{key:"a",text_en:"algorithms",text_zh:"演算法"},{key:"b",text_en:"operating systems",text_zh:"作業系統"},{key:"c",text_en:"computer languages",text_zh:"電腦語言"},{key:"d",text_en:"hardware",text_zh:"硬體"}],answer:"c",explanation_zh:"FORTRAN 和 COBOL 是早期的高階程式語言。FORTRAN 主要用於科學計算，COBOL 主要用於商業資料處理。"},{id:"1.9",chapter:"1",number:"1-9",text_en:"A 17th-century computing machine that could perform addition and subtraction was the ________.",text_zh:"17世紀能執行加減法運算的計算機器是 ________。",options:[{key:"a",text_en:"Babbage machine",text_zh:"巴貝奇機"},{key:"b",text_en:"Jacquard loom",text_zh:"緹花織布機"},{key:"c",text_en:"Analytical Engine",text_zh:"分析機"},{key:"d",text_en:"Pascaline",text_zh:"帕斯卡計算器"}],answer:"d",explanation_zh:"帕斯卡計算器（Pascaline）由布萊茲·帕斯卡於17世紀發明，是第一台能執行加法和減法的機械式計算器。"},{id:"1.10",chapter:"1",number:"1-10",text_en:"________ is a set of instructions in a computer language that tells the computer what to do with data.",text_zh:"________ 是一組用電腦語言寫成的指令，告訴電腦如何處理資料。",options:[{key:"a",text_en:"A program",text_zh:"程式"},{key:"b",text_en:"An algorithm",text_zh:"演算法"},{key:"c",text_en:"A data processor",text_zh:"資料處理器"},{key:"d",text_en:"An operating system",text_zh:"作業系統"}],answer:"a",explanation_zh:"程式（program）是一系列電腦可以理解和執行的指令，它告訴電腦如何處理資料以完成特定任務。"},{id:"1.11",chapter:"1",number:"1-11",text_en:"________ is the design and writing of a program in structured form.",text_zh:"________ 是以結構化形式設計和編寫程式的過程。",options:[{key:"a",text_en:"Instructional architecture",text_zh:"指令架構"},{key:"b",text_en:"Hardware engineering",text_zh:"硬體工程"},{key:"c",text_en:"Algorithm development",text_zh:"演算法開發"},{key:"d",text_en:"Software engineering",text_zh:"軟體工程"}],answer:"d",explanation_zh:"軟體工程（Software engineering）是一門將系統化、紀律化、可量化的方法應用於軟體開發、運維和維護的學科。"},{id:"1.12",chapter:"1",number:"1-12",text_en:"The first electronic special-purpose computer was called ________.",text_zh:"第一台電子專用電腦被稱為 ________。",options:[{key:"a",text_en:"ENIAC",text_zh:"ENIAC"},{key:"b",text_en:"Pascaline",text_zh:"帕斯卡計算器"},{key:"c",text_en:"ABC",text_zh:"ABC"},{key:"d",text_en:"Pascal",text_zh:"帕斯卡"}],answer:"c",explanation_zh:"第一台電子專用電腦是阿塔納索夫-貝瑞電腦（Atanasoff-Berry Computer, ABC），於1937年設計，用於求解線性方程組。"},{id:"1.13",chapter:"1",number:"1-13",text_en:"One of the first computers based on the von Neumann model was called ________.",text_zh:"第一批基於馮·諾伊曼模型的電腦之一被稱為 ________。",options:[{key:"a",text_en:"EDVAC",text_zh:"EDVAC"},{key:"b",text_en:"Pascaline",text_zh:"帕斯卡計算器"},{key:"c",text_en:"ABC",text_zh:"ABC"},{key:"d",text_en:"Pascal",text_zh:"帕斯卡"}],answer:"a",explanation_zh:"EDVAC (Electronic Discrete Variable Automatic Computer) 是最早基於馮·諾伊曼儲存程式概念設計的電腦之一。"},{id:"1.14",chapter:"1",number:"1-14",text_en:"The first computing machine to use the idea of storage and programming was called ________.",text_zh:"第一台使用儲存和程式設計思想的計算機器被稱為 ________。",options:[{key:"a",text_en:"the Jacquard loom",text_zh:"緹花織布機"},{key:"b",text_en:"EDVAC",text_zh:"EDVAC"},{key:"c",text_en:"the Babbage machine",text_zh:"巴貝奇機"},{key:"d",text_en:"the Madeline",text_zh:"瑪德琳機"}],answer:"a",explanation_zh:"緹花織布機（Jacquard loom）由約瑟夫·瑪麗·雅卡爾於1801年發明，使用打孔卡片來控制織布圖案，被認為是程式設計和資料儲存概念的早期應用。"},{id:"1.15",chapter:"1",number:"1-15",text_en:"________ separated the programming task from computer operation tasks.",text_zh:"________ 將程式設計任務與電腦操作任務分開。",options:[{key:"a",text_en:"Operating systems",text_zh:"作業系統"},{key:"b",text_en:"Data processors",text_zh:"資料處理器"},{key:"c",text_en:"High-level programming languages",text_zh:"高階程式語言"},{key:"d",text_en:"Algorithms",text_zh:"演算法"}],answer:"c",explanation_zh:"高階程式語言（High-level programming languages）的出現，使得程式設計師可以用更接近人類語言的方式撰寫程式，而不需要了解底層的硬體操作細節，從而將程式設計與電腦操作分開。"}],t=[{id:"2.1",chapter:"2",number:"2-1",text_en:"The base of the decimal number system is ________.",text_zh:"十進位數字系統的基底是 ________。",options:[{key:"a",text_en:"8",text_zh:"8"},{key:"b",text_en:"16",text_zh:"16"},{key:"c",text_en:"10",text_zh:"10"},{key:"d",text_en:"2",text_zh:"2"}],answer:"c",explanation_zh:"十進位（Decimal）數字系統以 10 為基底，使用 0 到 9 十個數字來表示數值。"},{id:"2.2",chapter:"2",number:"2-2",text_en:"The base of the binary number system is ________.",text_zh:"二進位數字系統的基底是 ________。",options:[{key:"a",text_en:"8",text_zh:"8"},{key:"b",text_en:"16",text_zh:"16"},{key:"c",text_en:"10",text_zh:"10"},{key:"d",text_en:"2",text_zh:"2"}],answer:"d",explanation_zh:"二進位（Binary）數字系統以 2 為基底，只使用 0 和 1 兩個數字來表示數值，是電腦內部運作的基礎。"},{id:"2.3",chapter:"2",number:"2-3",text_en:"The base of the octal number system is ________.",text_zh:"八進位數字系統的基底是 ________。",options:[{key:"a",text_en:"8",text_zh:"8"},{key:"b",text_en:"16",text_zh:"16"},{key:"c",text_en:"10",text_zh:"10"},{key:"d",text_en:"2",text_zh:"2"}],answer:"a",explanation_zh:"八進位（Octal）數字系統以 8 為基底，使用 0 到 7 八個數字來表示數值。"},{id:"2.4",chapter:"2",number:"2-4",text_en:"The base of the hexadecimal number system is ________.",text_zh:"十六進位數字系統的基底是 ________。",options:[{key:"a",text_en:"8",text_zh:"8"},{key:"b",text_en:"16",text_zh:"16"},{key:"c",text_en:"10",text_zh:"10"},{key:"d",text_en:"2",text_zh:"2"}],answer:"b",explanation_zh:"十六進位（Hexadecimal）數字系統以 16 為基底，使用 0-9 和 A-F（代表 10-15）十六個符號來表示數值。"},{id:"2.5",chapter:"2",number:"2-5",text_en:"When converting a decimal integer to base b, we repeatedly ________ b.",text_zh:"將十進位整數轉換為基底 b 時，我們重複地 ________ b。",options:[{key:"a",text_en:"multiply by",text_zh:"乘以"},{key:"b",text_en:"subtract from",text_zh:"減去"},{key:"c",text_en:"add to",text_zh:"加上"},{key:"d",text_en:"divide by",text_zh:"除以"}],answer:"d",explanation_zh:"將十進位整數轉換為其他基底 b 的方法是「除 b 取餘法」，即重複地用該數除以 b，並記錄每次的餘數，直到商為 0，然後將餘數由下往上排列。"},{id:"2.6",chapter:"2",number:"2-6",text_en:"When converting a decimal fraction to base b, we repeatedly ________ b.",text_zh:"將十進位分數轉換為基底 b 時，我們重複地 ________ b。",options:[{key:"a",text_en:"multiply by",text_zh:"乘以"},{key:"b",text_en:"subtract from",text_zh:"減去"},{key:"c",text_en:"add to",text_zh:"加上"},{key:"d",text_en:"divide by",text_zh:"除以"}],answer:"a",explanation_zh:"將十進位分數（小數）轉換為其他基底 b 的方法是「乘 b 取整法」，即重複地用小數部分乘以 b，並記錄每次的整數部分，直到小數部分為 0 或達到所需精度。"},{id:"2.7",chapter:"2",number:"2-7",text_en:"Which of the following representations is erroneous?",text_zh:"以下哪個表示法是錯誤的？",options:[{key:"a",text_en:"$(349)_8$",text_zh:"$(349)_8$"},{key:"b",text_en:"256",text_zh:"256"},{key:"c",text_en:"$(3AB)_{16}$",text_zh:"$(3AB)_{16}$"},{key:"d",text_en:"$(10111)_2$",text_zh:"$(10111)_2$"}],answer:"a",explanation_zh:"八進位（Octal, base 8）系統中只會出現 0 到 7 的數字，因此 $(349)_8$ 是錯誤的表示法，因為它包含了數字 9。"},{id:"2.8",chapter:"2",number:"2-8",text_en:"Which of the following representations is erroneous?",text_zh:"以下哪個表示法是錯誤的？",options:[{key:"a",text_en:"$(342)_8$",text_zh:"$(342)_8$"},{key:"b",text_en:"145",text_zh:"145"},{key:"c",text_en:"$(EEE)_{16}$",text_zh:"$(EEE)_{16}$"},{key:"d",text_en:"$(10211)_2$",text_zh:"$(10211)_2$"}],answer:"d",explanation_zh:"二進位（Binary, base 2）系統中只會出現 0 和 1 的數字，因此 $(10211)_2$ 是錯誤的表示法，因為它包含了數字 2。"},{id:"2.9",chapter:"2",number:"2-9",text_en:"Which of the following representations is erroneous?",text_zh:"以下哪個表示法是錯誤的？",options:[{key:"a",text_en:"$(346)_8$",text_zh:"$(346)_8$"},{key:"b",text_en:"221",text_zh:"221"},{key:"c",text_en:"$(EEG)_{16}$",text_zh:"$(EEG)_{16}$"},{key:"d",text_en:"$(111)_2$",text_zh:"$(111)_2$"}],answer:"c",explanation_zh:"十六進位（Hexadecimal, base 16）系統中只會出現 0-9 和 A-F 的符號，因此 $(EEG)_{16}$ 是錯誤的表示法，因為它包含了符號 G。"},{id:"2.10",chapter:"2",number:"2-10",text_en:"Which of the following representations is erroneous?",text_zh:"以下哪個表示法是錯誤的？",options:[{key:"a",text_en:"$(141)_8$",text_zh:"$(141)_8$"},{key:"b",text_en:"22A",text_zh:"22A"},{key:"c",text_en:"$(EF)_{16}$",text_zh:"$(EF)_{16}$"},{key:"d",text_en:"$(110)_2$",text_zh:"$(110)_2$"}],answer:"b",explanation_zh:"十進位（Decimal, base 10）系統中只會出現 0 到 9 的數字，22A 包含字母 A，因此不是一個有效的十進位表示。除非上下文另有說明，否則沒有下標的數字通常被視為十進位。"},{id:"2.11",chapter:"2",number:"2-11",text_en:"Which of the following is equivalent to 12 in decimal?",text_zh:"以下哪個等於十進位的 12？",options:[{key:"a",text_en:"$(1110)_2$",text_zh:"$(1110)_2$"},{key:"b",text_en:"$(C)_{16}$",text_zh:"$(C)_{16}$"},{key:"c",text_en:"$(15)_8$",text_zh:"$(15)_8$"},{key:"d",text_en:"None of the above",text_zh:"以上皆非"}],answer:"b",explanation_zh:"十進位的 12 等於十六進位的 C。 $(1110)_2 = 14_{10}$, $(15)_8 = 13_{10}$。"},{id:"2.12",chapter:"2",number:"2-12",text_en:"Which of the following is equivalent to 24 in decimal?",text_zh:"以下哪個等於十進位的 24？",options:[{key:"a",text_en:"$(1A)_{16}$",text_zh:"$(1A)_{16}$"},{key:"b",text_en:"None of the above",text_zh:"以上皆非"},{key:"c",text_en:"$(31)_8$",text_zh:"$(31)_8$"},{key:"d",text_en:"$(11000)_2$",text_zh:"$(11000)_2$"}],answer:"d",explanation_zh:"十進位的 24 等於二進位的 $(11000)_2$。 $(1A)_{16} = 26_{10}$, $(31)_8 = 25_{10}$。"}],_=[{id:"3.1",chapter:"3",number:"3-1",text_en:"A byte consists of ________ bits.",text_zh:"一個位元組由 ________ 個位元組成。",options:[{key:"a",text_en:"2",text_zh:"2"},{key:"b",text_en:"4",text_zh:"4"},{key:"c",text_en:"8",text_zh:"8"},{key:"d",text_en:"16",text_zh:"16"}],answer:"c",explanation_zh:"一個位元組（Byte）是電腦資訊計量的基本單位，通常由 8 個位元（bits）組成。"},{id:"3.2",chapter:"3",number:"3-2",text_en:"In a set of 64 symbols, each symbol requires a bit pattern length of ________ bits.",text_zh:"在一組 64 個符號的集合中，每個符號需要 ________ 位元的位元模式長度。",options:[{key:"a",text_en:"4",text_zh:"4"},{key:"b",text_en:"5",text_zh:"5"},{key:"c",text_en:"6",text_zh:"6"},{key:"d",text_en:"7",text_zh:"7"}],answer:"c",explanation_zh:"若要表示 64 個不同的符號，需要的位元數 $n$ 必須滿足 $2^n \\ge 64$。因為 $2^6 = 64$，所以需要 6 位元的長度。"},{id:"3.3",chapter:"3",number:"3-3",text_en:"How many symbols can be represented by a bit pattern with ten bits?",text_zh:"一個十位元的位元模式可以表示多少個符號？",options:[{key:"a",text_en:"128",text_zh:"128"},{key:"b",text_en:"256",text_zh:"256"},{key:"c",text_en:"512",text_zh:"512"},{key:"d",text_en:"1024",text_zh:"1024"}],answer:"d",explanation_zh:"一個 $n$ 位元的位元模式可以表示 $2^n$ 個不同的符號。因此，10 位元可以表示 $2^{10} = 1024$ 個符號。"},{id:"3.4",chapter:"3",number:"3-4",text_en:"If the ASCII code for E is 1000101, then the ASCII code for e is ________. Answer the question without consulting the ASCII table.",text_zh:"如果 E 的 ASCII 碼是 1000101，那麼 e 的 ASCII 碼是 ________。不查 ASCII 表回答問題。",options:[{key:"a",text_en:"1000110",text_zh:"1000110"},{key:"b",text_en:"1000111",text_zh:"1000111"},{key:"c",text_en:"0000110",text_zh:"0000110"},{key:"d",text_en:"1100101",text_zh:"1100101"}],answer:"d",explanation_zh:"在 ASCII 碼中，大寫字母和小寫字母的碼值相差 32。'E' 的 ASCII 碼是 $1000101_2$ (69)，'e' 的 ASCII 碼是 $1100101_2$ (101)。兩者相差 $0100000_2$ (32)。"},{id:"3.5",chapter:"3",number:"3-5",text_en:"A 32-bit code called ________ represents symbols in all languages.",text_zh:"一種稱為 ________ 的 32 位元代碼，用於表示所有語言的符號。",options:[{key:"a",text_en:"ANSI",text_zh:"ANSI"},{key:"b",text_en:"Unicode",text_zh:"Unicode"},{key:"c",text_en:"EBCDIC",text_zh:"EBCDIC"},{key:"d",text_en:"Extended ASCII",text_zh:"擴展ASCII"}],answer:"b",explanation_zh:"Unicode 是一個全球性的字元編碼標準，旨在為世界上所有語言的每個字元提供一個唯一的編號，它可以使用不同的編碼方案，如 UTF-8, UTF-16, UTF-32。"},{id:"3.6",chapter:"3",number:"3-6",text_en:"An image can be represented in a computer using the ________ method.",text_zh:"在電腦中，圖像可以使用 ________ 方法來表示。",options:[{key:"a",text_en:"bitmap graphic only",text_zh:"僅點陣圖"},{key:"b",text_en:"vector graphic only",text_zh:"僅向量圖"},{key:"c",text_en:"Excess system only",text_zh:"僅超額系統"},{key:"d",text_en:"either bitmap or vector graphic",text_zh:"點陣圖或向量圖"}],answer:"d",explanation_zh:"電腦圖像主要有兩種表示方法：點陣圖（bitmap graphic）和向量圖（vector graphic）。點陣圖由像素組成，向量圖由數學方程式定義的線條和形狀組成。"},{id:"3.7",chapter:"3",number:"3-7",text_en:"In the ________ graphic method of representing an image in a computer, each pixel is assigned a bit patterns.",text_zh:"在電腦中表示圖像的 ________ 圖形方法中，每個像素都被分配一個位元模式。",options:[{key:"a",text_en:"bitmap",text_zh:"點陣圖"},{key:"b",text_en:"vector",text_zh:"向量"},{key:"c",text_en:"quantized",text_zh:"量化"},{key:"d",text_en:"binary",text_zh:"二進位"}],answer:"a",explanation_zh:"在點陣圖（bitmap）表示法中，圖像被視為一個像素網格，每個像素都被分配一個位元模式來表示其顏色。"},{id:"3.8",chapter:"3",number:"3-8",text_en:"In the ________ graphic method of representing an image in a computer, the image is decomposed into a combination of geometrical figures.",text_zh:"在電腦中表示圖像的 ________ 圖形方法中，圖像被分解為幾何圖形的組合。",options:[{key:"a",text_en:"bitmap",text_zh:"點陣圖"},{key:"b",text_en:"vector",text_zh:"向量"},{key:"c",text_en:"quantized",text_zh:"量化"},{key:"d",text_en:"binary",text_zh:"二進位"}],answer:"b",explanation_zh:"在向量圖（vector）表示法中，圖像由一系列幾何圖形（如線條、曲線、多邊形）的數學描述組成。"},{id:"3.9",chapter:"3",number:"3-9",text_en:"In the ________ graphic method of representing an image in a computer, re-scaling of the image creates a ragged or grainy image.",text_zh:"在電腦中表示圖像的 ________ 圖形方法中，重新縮放圖像會產生鋸齒狀或顆粒狀的圖像。",options:[{key:"a",text_en:"bitmap",text_zh:"點陣圖"},{key:"b",text_en:"vector",text_zh:"向量"},{key:"c",text_en:"quantized",text_zh:"量化"},{key:"d",text_en:"binary",text_zh:"二進位"}],answer:"a",explanation_zh:"點陣圖（bitmap）在放大時，像素點會變大，導致圖像邊緣出現鋸齒狀或模糊，即「失真」。向量圖則可以無失真地縮放。"},{id:"3.10",chapter:"3",number:"3-10",text_en:"When we want to store music in a computer, the audio signal must be ________.",text_zh:"當我們想在電腦中儲存音樂時，音訊信號必須經過 ________ 處理。",options:[{key:"a",text_en:"sampled only",text_zh:"僅取樣"},{key:"b",text_en:"quantized only",text_zh:"僅量化"},{key:"c",text_en:"coded only",text_zh:"僅編碼"},{key:"d",text_en:"sampled, quantized, and coded",text_zh:"取樣、量化和編碼"}],answer:"d",explanation_zh:"將類比的音訊信號轉換為數位形式儲存在電腦中，需要經過三個步驟：取樣（Sampling）、量化（Quantization）和編碼（Coding）。"},{id:"3.11",chapter:"3",number:"3-11",text_en:"A floating-point value after normalization is $(1.0101) \\times 2^4$. What is the value of exponent section in the Excess-127 representation?",text_zh:"一個浮點數正規化後為 $(1.0101) \\times 2^4$。在 Excess-127 表示法中，指數部分的值是多少？",options:[{key:"a",text_en:"4",text_zh:"4"},{key:"b",text_en:"-4",text_zh:"-4"},{key:"c",text_en:"127",text_zh:"127"},{key:"d",text_en:"131",text_zh:"131"}],answer:"d",explanation_zh:"Excess-127 表示法中，實際指數值需要加上一個偏置值（bias）127。因此，指數 $4$ 在 Excess-127 中表示為 $4 + 127 = 131$。(註：原始考題選項D為123，可能是將指數誤植為 $-4$ 所致 ($127 - 4 = 123$)，但根據題目給出的正規化形式，指數應為 $+4$)。"},{id:"3.12",chapter:"3",number:"3-12",text_en:"Assume a new Excess system uses 17 bits to represent the exponent section. What is the bias value in this system?",text_zh:"假設一個新的超額系統使用 17 位元來表示指數部分。該系統中的偏置值是多少？",options:[{key:"a",text_en:"17",text_zh:"17"},{key:"b",text_en:"16",text_zh:"16"},{key:"c",text_en:"65535",text_zh:"65535"},{key:"d",text_en:"65536",text_zh:"65536"}],answer:"c",explanation_zh:"在一個使用 $n$ 位元表示指數的超額系統中，偏置值為 $2^{n-1} - 1$。對於 17 位元，偏置值是 $2^{17-1} - 1 = 2^{16} - 1 = 65536 - 1 = 65535$。"},{id:"3.13",chapter:"3",number:"3-13",text_en:"Which number representation method is often used to store the exponential value of a fractional part?",text_zh:"哪種數字表示法常用於儲存小數部分的指數值？",options:[{key:"a",text_en:"unsigned integers",text_zh:"無符號整數"},{key:"b",text_en:"two's complement",text_zh:"二的補數"},{key:"c",text_en:"Excess",text_zh:"超額表示法"},{key:"d",text_en:"ten's complement",text_zh:"十的補數"}],answer:"c",explanation_zh:"超額表示法（Excess representation）常用於浮點數表示法中儲存指數部分，因為它可以將負指數對應到一個正的二進位數，簡化了指數大小的比較。"},{id:"3.14",chapter:"3",number:"3-14",text_en:"In an Excess conversion, we ________ the number to be converted.",text_zh:"在超額表示法轉換中，我們對要轉換的數字 ________。",options:[{key:"a",text_en:"add the bias number to",text_zh:"加上偏置數"},{key:"b",text_en:"subtract the bias number from",text_zh:"減去偏置數"},{key:"c",text_en:"multiply the bias number by",text_zh:"乘以偏置數"},{key:"d",text_en:"divide the bias number by",text_zh:"除以偏置數"}],answer:"a",explanation_zh:"在超額表示法轉換中，我們將要轉換的數字加上偏置數（bias），然後將結果轉換為無符號二進位數。"},{id:"3.15",chapter:"3",number:"3-15",text_en:"When a fractional part is normalized, the computer stores the ________.",text_zh:"當小數部分被正規化時，電腦儲存 ________。",options:[{key:"a",text_en:"only the sign",text_zh:"僅符號"},{key:"b",text_en:"only the exponent",text_zh:"僅指數"},{key:"c",text_en:"only the mantissa",text_zh:"僅尾數"},{key:"d",text_en:"the sign, exponent, and mantissa",text_zh:"符號、指數和尾數"}],answer:"d",explanation_zh:"浮點數在電腦中儲存時，通常會將其正規化，然後分別儲存三個部分：符號（sign）、指數（exponent）和尾數（mantissa）。"},{id:"3.16",chapter:"3",number:"3-16",text_en:"The precision of the fractional part of a number stored in a computer is defined by the ________.",text_zh:"電腦中儲存的數字小數部分的精度由 ________ 定義。",options:[{key:"a",text_en:"sign",text_zh:"符號"},{key:"b",text_en:"exponent",text_zh:"指數"},{key:"c",text_en:"mantissa",text_zh:"尾數"},{key:"d",text_en:"last digit",text_zh:"最後一位數字"}],answer:"c",explanation_zh:"尾數（mantissa）部分儲存了數字的有效數字，其位元數的多少直接決定了浮點數的精度（precision）。"},{id:"3.17",chapter:"3",number:"3-17",text_en:"The combination of sign and mantissa of a real number in IEEE standard floating point format is stored as an integer in the ________ representation.",text_zh:"在 IEEE 標準浮點格式中，實數的符號和尾數的組合以 ________ 表示法儲存為整數。",options:[{key:"a",text_en:"unsigned",text_zh:"無符號"},{key:"b",text_en:"sign-and-magnitude",text_zh:"符號和數值"},{key:"c",text_en:"two's complement",text_zh:"二的補數"},{key:"d",text_en:"one's complement",text_zh:"一的補數"}],answer:"b",explanation_zh:"IEEE 754 標準浮點格式中，符號位獨立儲存。尾數部分則被視為一個正數。因此，符號和尾數的組合可以看作是符號-數值（sign-and-magnitude）表示法。"}],n=[{id:"4.1",chapter:"4",number:"4-1",text_en:"________ is an arithmetic operation.",text_zh:"________ 是一種算術運算。",options:[{key:"a",text_en:"The exclusive OR",text_zh:"互斥或"},{key:"b",text_en:"Subtraction",text_zh:"減法"},{key:"c",text_en:"The unary NOT",text_zh:"一元非"},{key:"d",text_en:"The binary AND",text_zh:"二元與"}],answer:"b",explanation_zh:"減法（Subtraction）是一種基本的算術運算。AND、OR、XOR 和 NOT 則是邏輯運算。"},{id:"4.2",chapter:"4",number:"4-2",text_en:"________ is a logical bit operator.",text_zh:"________ 是一種邏輯位元運算子。",options:[{key:"a",text_en:"The exclusive OR",text_zh:"互斥或"},{key:"b",text_en:"The binary AND",text_zh:"二元與"},{key:"c",text_en:"The unary NOT",text_zh:"一元非"},{key:"d",text_en:"exclusive OR, unary NOT, or binary AND",text_zh:"互斥或、一元非或二元與"}],answer:"d",explanation_zh:"邏輯位元運算子對二進位數的每一位進行操作。互斥或（XOR）、一元非（unary NOT）和二元與（binary AND）都屬於邏輯位元運算子。"},{id:"4.3",chapter:"4",number:"4-3",text_en:"The ________ method of integer representation is the most common method for storing integers in computer memory.",text_zh:"________ 整數表示法是電腦記憶體中儲存整數最常見的方法。",options:[{key:"a",text_en:"sign-and-magnitude",text_zh:"符號和數值"},{key:"b",text_en:"two's complement",text_zh:"二的補數"},{key:"c",text_en:"one's complement",text_zh:"一的補數"},{key:"d",text_en:"unsigned integers",text_zh:"無符號整數"}],answer:"b",explanation_zh:"二的補數（two's complement）是電腦系統中最常用來表示和處理有符號整數的方法，因為它簡化了加法和減法運算。"},{id:"4.4",chapter:"4",number:"4-4",text_en:"In two's complement addition, if there is a final carry after the left most column addition, ________.",text_zh:"在二的補數加法中，如果最左邊一欄相加後有最終進位，則 ________。",options:[{key:"a",text_en:"add it to the right most column",text_zh:"將其加到最右邊一欄"},{key:"b",text_en:"discard it",text_zh:"將其丟棄"},{key:"c",text_en:"add it to the left most column",text_zh:"將其加到最左邊一欄"},{key:"d",text_en:"increase the bit length",text_zh:"增加位元長度"}],answer:"b",explanation_zh:"在二的補數加法中，如果最高位（最左邊）相加產生了進位，這個進位應該被直接丟棄。這個特性使得加法和減法可以使用相同的電路來實現。"},{id:"4.5",chapter:"4",number:"4-5",text_en:"For an 8-bit allocation, the smallest decimal number that can be represented in two's complement form is ________.",text_zh:"對於 8 位元的配置，可以用二的補數形式表示的最小十進位數是 ________。",options:[{key:"a",text_en:"-8",text_zh:"-8"},{key:"b",text_en:"-128",text_zh:"-128"},{key:"c",text_en:"-127",text_zh:"-127"},{key:"d",text_en:"-256",text_zh:"-256"}],answer:"b",explanation_zh:"對於 $n$ 位元的二的補數表示法，可表示的範圍是 $-2^{n-1}$ 到 $2^{n-1} - 1$。對於 8 位元，範圍是 $-2^7$ 到 $2^7 - 1$，即 $-128$ 到 $127$。最小數為 $-128$。"},{id:"4.6",chapter:"4",number:"4-6",text_en:"For an 8-bit allocation, the largest decimal number that can be represented in two's complement form is ________.",text_zh:"對於 8 位元的配置，可以用二的補數形式表示的最大十進位數是 ________。",options:[{key:"a",text_en:"8",text_zh:"8"},{key:"b",text_en:"128",text_zh:"128"},{key:"c",text_en:"127",text_zh:"127"},{key:"d",text_en:"256",text_zh:"256"}],answer:"c",explanation_zh:"對於 $n$ 位元的二的補數表示法，可表示的範圍是 $-2^{n-1}$ 到 $2^{n-1} - 1$。對於 8 位元，範圍是 $-128$ 到 $127$。最大數為 $127$。"},{id:"4.7",chapter:"4",number:"4-7",text_en:"In two's complement representation with a 4-bit allocation, we get ________ when we add 1 to 7.",text_zh:"在 4 位元配置的二的補數表示法中，當我們將 1 加到 7 時，得到 ________。",options:[{key:"a",text_en:"8",text_zh:"8"},{key:"b",text_en:"-7",text_zh:"-7"},{key:"c",text_en:"1",text_zh:"1"},{key:"d",text_en:"-8",text_zh:"-8"}],answer:"d",explanation_zh:"在 4 位元二的補數中，$7_{10} = 0111_2$。加 1 後為 $1000_2$。因為最高位是 1，這是一個負數。$1000_2$ 的二的補數是它本身，代表的十進位數是 $-8_{10}$。這是一個溢位（overflow）的例子。"},{id:"4.8",chapter:"4",number:"4-8",text_en:"In two's complement representation with a 4-bit allocation, we get ________ when we add 5 to 5.",text_zh:"在 4 位元配置的二的補數表示法中，當我們將 5 加到 5 時，得到 ________。",options:[{key:"a",text_en:"-5",text_zh:"-5"},{key:"b",text_en:"-7",text_zh:"-7"},{key:"c",text_en:"-6",text_zh:"-6"},{key:"d",text_en:"10",text_zh:"10"}],answer:"c",explanation_zh:"在 4 位元二的補數中，$5_{10}$ 的表示為 $0101_2$。$5 + 5 = 10$，二進位相加為 $0101_2 + 0101_2 = 1010_2$。最高位是 1，為負數。取其二的補數得到 $0110_2$，即 6。所以 $1010_2$ 代表 $-6_{10}$。這也是一個溢位的例子。"},{id:"4.9",chapter:"4",number:"4-9",text_en:"If the exponent in Excess_127 is binary 10000101, the exponent in decimal is ________.",text_zh:"如果 Excess_127 中的指數是二進位的 10000101，那麼十進位的指數是 ________。",options:[{key:"a",text_en:"6",text_zh:"6"},{key:"b",text_en:"8",text_zh:"8"},{key:"c",text_en:"7",text_zh:"7"},{key:"d",text_en:"9",text_zh:"9"}],answer:"a",explanation_zh:"在 Excess_127 表示法中，要得到真實的指數值，需要將二進位表示轉換為十進位後再減去偏置值 127。二進位 $10000101_2$ 等於十進位 $133_{10}$ ($128+4+1$)。所以真實指數是 $133 - 127 = 6$。"},{id:"4.10",chapter:"4",number:"4-10",text_en:"If we are adding two numbers, one of which has an exponent value of 7 and the other an exponent value of 9, we need to shift the decimal point of the smaller number ________.",text_zh:"如果我們相加兩個數字，其中一個的指數值為 7，另一個的指數值為 9，我們需要將較小數字的小數點向 ________ 移動。",options:[{key:"a",text_en:"one place to the left",text_zh:"左移一位"},{key:"b",text_en:"two places to the left",text_zh:"左移兩位"},{key:"c",text_en:"one place to the right",text_zh:"右移一位"},{key:"d",text_en:"two places to the right",text_zh:"右移兩位"}],answer:"b",explanation_zh:"在進行浮點數加法時，需要先對齊指數。將指數較小的數的尾數向右移動，每移動一位，指數加一。為了將指數 7 對齊到 9，需要將指數為 7 的數的尾數向右移動 $9 - 7 = 2$ 位，這相當於將其小數點向左移動兩位。"},{id:"4.11",chapter:"4",number:"4-11",text_en:"________ operator(s) takes two inputs to produce one output.",text_zh:"________ 運算子接受兩個輸入以產生一個輸出。",options:[{key:"a",text_en:"Only AND",text_zh:"僅 AND"},{key:"b",text_en:"Only XOR",text_zh:"僅 XOR"},{key:"c",text_en:"Only OR",text_zh:"僅 OR"},{key:"d",text_en:"AND, OR, or XOR",text_zh:"AND、OR 或 XOR"}],answer:"d",explanation_zh:"二元運算子（binary operator）接受兩個輸入（運算元）來產生一個輸出。AND, OR, XOR 都是二元運算子。NOT 是一元運算子。"},{id:"4.12",chapter:"4",number:"4-12",text_en:"The unary ________ operator inverts its single input.",text_zh:"一元 ________ 運算子會反轉其單一輸入。",options:[{key:"a",text_en:"AND",text_zh:"AND"},{key:"b",text_en:"NOT",text_zh:"NOT"},{key:"c",text_en:"OR",text_zh:"OR"},{key:"d",text_en:"XOR",text_zh:"XOR"}],answer:"b",explanation_zh:"一元（unary）運算子只接受一個輸入。NOT 運算子（也稱為反相器）會將其輸入的位元反轉（0 變 1，1 變 0）。"},{id:"4.13",chapter:"4",number:"4-13",text_en:"________ operator(s), if the input is two 0s, the output is 0.",text_zh:"________ 運算子，如果輸入是兩個 0，輸出是 0。",options:[{key:"a",text_en:"In only AND",text_zh:"僅 AND"},{key:"b",text_en:"In only XOR",text_zh:"僅 XOR"},{key:"c",text_en:"In only OR",text_zh:"僅 OR"},{key:"d",text_en:"In AND, OR, or XOR",text_zh:"在 AND、OR 或 XOR 中"}],answer:"d",explanation_zh:"AND: $0 \\& 0 = 0$. OR: $0 | 0 = 0$. XOR: $0 \\oplus 0 = 0$. 所以三者在輸入為兩個 0 時，輸出都是 0。"},{id:"4.14",chapter:"4",number:"4-14",text_en:"________ operator(s), if the input is two 1s, the output is 0.",text_zh:"________ 運算子，如果輸入是兩個 1，輸出是 0。",options:[{key:"a",text_en:"In only AND",text_zh:"僅 AND"},{key:"b",text_en:"In only XOR",text_zh:"僅 XOR"},{key:"c",text_en:"In only OR",text_zh:"僅 OR"},{key:"d",text_en:"In AND, OR, or XOR",text_zh:"在 AND、OR 或 XOR 中"}],answer:"b",explanation_zh:"XOR (互斥或) 運算子的規則是：當兩個輸入位元不同時，輸出為 1；相同時，輸出為 0。因此當輸入是兩個 1 時，輸出是 0。"},{id:"4.15",chapter:"4",number:"4-15",text_en:"For the binary AND operation, only an input of ________ gives an output of 1.",text_zh:"對於二進位 AND 運算，只有 ________ 的輸入會得到 1 的輸出。",options:[{key:"a",text_en:"two 0s",text_zh:"兩個 0"},{key:"b",text_en:"one 0 and one 1",text_zh:"一個 0 和一個 1"},{key:"c",text_en:"two 1s",text_zh:"兩個 1"},{key:"d",text_en:"two 2s",text_zh:"兩個 2"}],answer:"c",explanation_zh:"對於 AND 運算，只有當所有輸入都為 1 時，輸出才為 1。"},{id:"4.16",chapter:"4",number:"4-16",text_en:"For the binary OR operation, only an input of ________ gives an output of 0.",text_zh:"對於二進位 OR 運算，只有 ________ 的輸入會得到 0 的輸出。",options:[{key:"a",text_en:"two 0s",text_zh:"兩個 0"},{key:"b",text_en:"one 0 and one 1",text_zh:"一個 0 和一個 1"},{key:"c",text_en:"two 1s",text_zh:"兩個 1"},{key:"d",text_en:"two 2s",text_zh:"兩個 2"}],answer:"a",explanation_zh:"對於 OR 運算，只有當所有輸入都為 0 時，輸出才為 0。"},{id:"4.17",chapter:"4",number:"4-17",text_en:"We use a bit pattern called a ________ to modify another bit pattern.",text_zh:"我們使用稱為 ________ 的位元模式來修改另一個位元模式。",options:[{key:"a",text_en:"mask",text_zh:"遮罩"},{key:"b",text_en:"float",text_zh:"浮點數"},{key:"c",text_en:"carry",text_zh:"進位"},{key:"d",text_en:"byte",text_zh:"位元組"}],answer:"a",explanation_zh:"遮罩（mask）是一個位元模式，用於位元運算中，可以選擇性地修改、選取或清除另一個位元模式中的某些位元。"},{id:"4.18",chapter:"4",number:"4-18",text_en:"To flip all the bits of a bit pattern, make a mask of all 1s and then ________ the bit pattern and the mask.",text_zh:"要反轉位元模式的所有位元，請建立一個全為 1 的遮罩，然後將該位元模式與遮罩進行 ________ 運算。",options:[{key:"a",text_en:"AND",text_zh:"AND"},{key:"b",text_en:"XOR",text_zh:"XOR"},{key:"c",text_en:"OR",text_zh:"OR"},{key:"d",text_en:"NOT",text_zh:"NOT"}],answer:"b",explanation_zh:"要反轉（flip）一個位元模式的所有位元，可以使用 XOR 運算。任何位元 A XOR 1 的結果都是 A 的反轉。因此，使用一個全為 1 的遮罩進行 XOR 運算可以反轉所有位元。"},{id:"4.19",chapter:"4",number:"4-19",text_en:"To un-set (force to 0) all the bits of a bit pattern, make a mask of all 0s and then ________ the bit pattern and the mask.",text_zh:"要取消設定 (強制為 0) 位元模式的所有位元，請建立一個全為 0 的遮罩，然後將該位元模式與遮罩進行 ________ 運算。",options:[{key:"a",text_en:"AND",text_zh:"AND"},{key:"b",text_en:"XOR",text_zh:"XOR"},{key:"c",text_en:"OR",text_zh:"OR"},{key:"d",text_en:"NOT",text_zh:"NOT"}],answer:"a",explanation_zh:"要取消設定（un-set，強制為 0）一個位元模式中的某些位元，可以使用 AND 運算。任何位元 A AND 0 的結果都是 0。因此，使用一個全為 0 的遮罩進行 AND 運算可以將所有位元強制為 0。"},{id:"4.20",chapter:"4",number:"4-20",text_en:"To set (force to 1) all the bits of a bit pattern, make a mask of all 1s and then ________ the bit pattern and the mask.",text_zh:"要設定 (強制為 1) 位元模式的所有位元，請建立一個全為 1 的遮罩，然後將該位元模式與遮罩進行 ________ 運算。",options:[{key:"a",text_en:"AND",text_zh:"AND"},{key:"b",text_en:"XOR",text_zh:"XOR"},{key:"c",text_en:"OR",text_zh:"OR"},{key:"d",text_en:"NOT",text_zh:"NOT"}],answer:"c",explanation_zh:"要設定（set，強制為 1）一個位元模式中的某些位元，可以使用 OR 運算。任何位元 A OR 1 的結果都是 1。因此，使用一個全為 1 的遮罩進行 OR 運算可以將所有位元強制為 1。"}],a=[{id:"5.1",chapter:"5",number:"5-1",text_en:"The ________ is a computer subsystem that performs operations on data.",text_zh:"________ 是一個對資料執行操作的電腦子系統。",options:[{key:"a",text_en:"memory",text_zh:"記憶體"},{key:"b",text_en:"I/O hardware",text_zh:"I/O 硬體"},{key:"c",text_en:"bus subsystem",text_zh:"匯流排子系統"},{key:"d",text_en:"CPU",text_zh:"中央處理器"}],answer:"d",explanation_zh:"CPU (Central Processing Unit) 是電腦的核心，負責解釋和執行程式指令，以及對資料進行算術和邏輯運算。"},{id:"5.2",chapter:"5",number:"5-2",text_en:"________ is a stand-alone storage location that holds data temporarily.",text_zh:"________ 是一個獨立的儲存位置，用於暫時保存資料。",options:[{key:"a",text_en:"A register",text_zh:"暫存器"},{key:"b",text_en:"A control unit",text_zh:"控制單元"},{key:"c",text_en:"A tape drive",text_zh:"磁帶機"},{key:"d",text_en:"An ALU",text_zh:"算術邏輯單元"}],answer:"a",explanation_zh:"暫存器（Register）是 CPU 內部的高速儲存單元，用於暫時存放指令、資料和記憶體位址。"},{id:"5.3",chapter:"5",number:"5-3",text_en:"________ is a unit that can add two inputs.",text_zh:"________ 是一個可以將兩個輸入相加的單元。",options:[{key:"a",text_en:"A register",text_zh:"暫存器"},{key:"b",text_en:"A control unit",text_zh:"控制單元"},{key:"c",text_en:"A tape drive",text_zh:"磁帶機"},{key:"d",text_en:"An ALU",text_zh:"算術邏輯單元"}],answer:"d",explanation_zh:"算術邏輯單元（ALU）是 CPU 的一部分，負責執行算術運算（如加法）和邏輯運算。"},{id:"5.4",chapter:"5",number:"5-4",text_en:"A register in a CPU can hold ________.",text_zh:"CPU 中的暫存器可以保存 ________。",options:[{key:"a",text_en:"only instructions",text_zh:"僅指令"},{key:"b",text_en:"only program counter values",text_zh:"僅程式計數器值"},{key:"c",text_en:"data, instruction, or program counter values",text_zh:"資料、指令或程式計數器值"},{key:"d",text_en:"only data",text_zh:"僅資料"}],answer:"c",explanation_zh:"CPU 中的暫存器用途廣泛，可以儲存正在執行的指令、運算所需的資料、記憶體位址，以及指向下一條指令位址的程式計數器（Program Counter）值。"},{id:"5.5",chapter:"5",number:"5-5",text_en:"A control unit with five wires can define up to ________ operations.",text_zh:"一個有五條線的控制單元最多可以定義 ________ 種操作。",options:[{key:"a",text_en:"10",text_zh:"10"},{key:"b",text_en:"16",text_zh:"16"},{key:"c",text_en:"32",text_zh:"32"},{key:"d",text_en:"5",text_zh:"5"}],answer:"c",explanation_zh:"一個有 $n$ 條線的控制單元可以定義 $2^n$ 種不同的操作。因此，五條線可以定義 $2^5 = 32$ 種操作。"},{id:"5.6",chapter:"5",number:"5-6",text_en:"A word can be ________ bits.",text_zh:"一個字可以是 ________ 位元。",options:[{key:"a",text_en:"only 16",text_zh:"僅 16"},{key:"b",text_en:"only 32",text_zh:"僅 32"},{key:"c",text_en:"8, or 16, or 32",text_zh:"8、16 或 32"},{key:"d",text_en:"only 8",text_zh:"僅 8"}],answer:"c",explanation_zh:"字（word）是電腦進行資料處理和運算的單位，其長度（位元數）取決於 CPU 的設計，可以是 8, 16, 32, 64 位元等。"},{id:"5.7",chapter:"5",number:"5-7",text_en:"If the memory address space is 16 MB and the word size is 8 bits, then ________ bits are needed to access each word.",text_zh:"如果記憶體位址空間為 16 MB，字組大小為 8 位元，那麼需要 ________ 位元來存取每個字。",options:[{key:"a",text_en:"16",text_zh:"16"},{key:"b",text_en:"24",text_zh:"24"},{key:"c",text_en:"32",text_zh:"32"},{key:"d",text_en:"8",text_zh:"8"}],answer:"b",explanation_zh:"$16 \\text{ MB} = 16 \\times 2^{20} \\text{ Bytes} = 2^4 \\times 2^{20} = 2^{24} \\text{ Bytes}$。因為字組大小是 8 位元（1 Byte），所以記憶體中有 $2^{24}$ 個字。要為 $2^{24}$ 個不同的位址進行編碼，需要 24 位元。"},{id:"5.8",chapter:"5",number:"5-8",text_en:"The data in ________ is erased if the computer is powered down.",text_zh:"如果電腦斷電，________ 中的資料將被清除。",options:[{key:"a",text_en:"ROM",text_zh:"唯讀記憶體"},{key:"b",text_en:"a tape drive",text_zh:"磁帶機"},{key:"c",text_en:"a CD-ROM",text_zh:"光碟"},{key:"d",text_en:"RAM",text_zh:"隨機存取記憶體"}],answer:"d",explanation_zh:"RAM (Random Access Memory) 是一種揮發性記憶體，儲存的資料在電腦斷電後會消失。ROM、磁帶和 CD-ROM 都是非揮發性的。"},{id:"5.9",chapter:"5",number:"5-9",text_en:"________ is a memory type with capacitors that need to be refreshed periodically.",text_zh:"________ 是一種帶有電容器的記憶體類型，需要定期刷新。",options:[{key:"a",text_en:"DRAM",text_zh:"動態隨機存取記憶體"},{key:"b",text_en:"ROM",text_zh:"唯讀記憶體"},{key:"c",text_en:"CROM",text_zh:"CROM"},{key:"d",text_en:"SRAM",text_zh:"靜態隨機存取記憶體"}],answer:"a",explanation_zh:"DRAM (Dynamic RAM) 使用電容器來儲存位元，電容器會隨時間漏電，因此需要定期刷新（refresh）來維持資料。"},{id:"5.10",chapter:"5",number:"5-10",text_en:"________ is a memory type with traditional flip-flop gates to hold data.",text_zh:"________ 是一種使用傳統正反器閘門來保存資料的記憶體類型。",options:[{key:"a",text_en:"DRAM",text_zh:"動態隨機存取記憶體"},{key:"b",text_en:"ROM",text_zh:"唯讀記憶體"},{key:"c",text_en:"CROM",text_zh:"CROM"},{key:"d",text_en:"SRAM",text_zh:"靜態隨機存取記憶體"}],answer:"d",explanation_zh:"SRAM (Static RAM) 使用正反器（flip-flop）電路來儲存位元，只要有電力供應，資料就可以一直保持，不需要刷新，速度比 DRAM 快但成本更高。"},{id:"5.11",chapter:"5",number:"5-11",text_en:"There are ________ bytes in 16 Terabytes.",text_zh:"16 TB 中有 ________ 個位元組。",options:[{key:"a",text_en:"$2^{56}$",text_zh:"$2^{56}$"},{key:"b",text_en:"$2^{40}$",text_zh:"$2^{40}$"},{key:"c",text_en:"$2^{44}$",text_zh:"$2^{44}$"},{key:"d",text_en:"$2^{54}$",text_zh:"$2^{54}$"}],answer:"c",explanation_zh:"$1 \\text{ Terabyte (TB)} = 2^{40} \\text{ Bytes}$。$16 \\text{ TB} = 16 \\times 2^{40} = 2^4 \\times 2^{40} = 2^{44} \\text{ Bytes}$。"},{id:"5.12",chapter:"5",number:"5-12",text_en:"________ can be programmed and erased using electronic impulses but can remain in a computer during erasure.",text_zh:"________ 可以使用電子脈衝進行編程和擦除，但在擦除過程中可以保留在電腦中。",options:[{key:"a",text_en:"PROM",text_zh:"可程式化唯讀記憶體"},{key:"b",text_en:"EPROM",text_zh:"可抹除可程式化唯讀記憶體"},{key:"c",text_en:"EEPROM",text_zh:"電子式可抹除可程式化唯讀記憶體"},{key:"d",text_en:"ROM",text_zh:"唯讀記憶體"}],answer:"c",explanation_zh:"EEPROM (Electrically Erasable Programmable Read-Only Memory) 是一種非揮發性記憶體，可以透過電子方式進行編程和擦除，且擦除時不需要從電腦中取出。"},{id:"5.13",chapter:"5",number:"5-13",text_en:"________ is a type of memory in which the user, not the manufacturer, stores programs that cannot be overwritten.",text_zh:"________ 是一種記憶體類型，其中由使用者而非製造商儲存無法覆寫的程式。",options:[{key:"a",text_en:"PROM",text_zh:"可程式化唯讀記憶體"},{key:"b",text_en:"EPROM",text_zh:"可抹除可程式化唯讀記憶體"},{key:"c",text_en:"EEPROM",text_zh:"電子式可抹除可程式化唯讀記憶體"},{key:"d",text_en:"ROM",text_zh:"唯讀記憶體"}],answer:"a",explanation_zh:"PROM (Programmable Read-Only Memory) 是一種只能寫入一次的唯讀記憶體，由使用者（而非製造商）使用特殊設備進行編程。"},{id:"5.14",chapter:"5",number:"5-14",text_en:"Main memory in a computer usually consists of large amounts of ________ speed memory.",text_zh:"電腦中的主記憶體通常由大量的 ________ 速度記憶體組成。",options:[{key:"a",text_en:"medium",text_zh:"中等"},{key:"b",text_en:"low",text_zh:"低"},{key:"c",text_en:"very high speed",text_zh:"非常高速"},{key:"d",text_en:"high",text_zh:"高"}],answer:"b",explanation_zh:"主記憶體（Main memory），通常指 DRAM，其速度遠低於 CPU 內部的暫存器和快取記憶體。雖然比硬碟快，但在電腦架構層級中，相對於 CPU 的處理速度，其存取速度被視為較低速的組件。"},{id:"5.15",chapter:"5",number:"5-15",text_en:"A ________ is a storage device to which the user can write information only once.",text_zh:"________ 是一種使用者只能寫入資訊一次的儲存設備。",options:[{key:"a",text_en:"CD-R",text_zh:"CD-R"},{key:"b",text_en:"CD-RW",text_zh:"CD-RW"},{key:"c",text_en:"CD-RR",text_zh:"CD-RR"},{key:"d",text_en:"CD-ROM",text_zh:"CD-ROM"}],answer:"a",explanation_zh:"CD-R (Compact Disc-Recordable) 是一種一次性寫入的光碟，使用者可以將資料寫入其中，但寫入後無法修改或刪除。"},{id:"5.16",chapter:"5",number:"5-16",text_en:"A ________ is a storage device that can undergo multiple writes and erasures.",text_zh:"________ 是一種可以進行多次寫入和擦除的儲存設備。",options:[{key:"a",text_en:"CD-R",text_zh:"CD-R"},{key:"b",text_en:"CD-RW",text_zh:"CD-RW"},{key:"c",text_en:"CD-RR",text_zh:"CD-RR"},{key:"d",text_en:"CD-ROM",text_zh:"CD-ROM"}],answer:"b",explanation_zh:"CD-RW (Compact Disc-ReWritable) 是一種可重複讀寫的光碟，使用者可以多次寫入、刪除和覆寫資料。"},{id:"5.17",chapter:"5",number:"5-17",text_en:"The smallest storage area on a magnetic disk that can be accessed at one time is a ________.",text_zh:"磁碟上一次可以存取的最小儲存區域是 ________。",options:[{key:"a",text_en:"sector",text_zh:"磁區"},{key:"b",text_en:"frame",text_zh:"框架"},{key:"c",text_en:"head",text_zh:"磁頭"},{key:"d",text_en:"track",text_zh:"磁軌"}],answer:"a",explanation_zh:"在磁碟中，資料儲存在同心圓的磁軌（track）上，每個磁軌又被劃分為數個磁區（sector）。磁區是磁碟讀寫操作的最小單位。"},{id:"5.18",chapter:"5",number:"5-18",text_en:"If the memory has $2^{32}$ words, the address bus needs to have ________ wires.",text_zh:"如果記憶體有 $2^{32}$ 個字，位址匯流排需要有 ________ 條線。",options:[{key:"a",text_en:"16",text_zh:"16"},{key:"b",text_en:"32",text_zh:"32"},{key:"c",text_en:"64",text_zh:"64"},{key:"d",text_en:"8",text_zh:"8"}],answer:"b",explanation_zh:"位址匯流排的線數（寬度）決定了 CPU 可以定址的最大記憶體空間。若要定址 $2^N$ 個字，位址匯流排需要有 $N$ 條線。因此，對於 $2^{32}$ 個字，需要 32 條線。"},{id:"5.19",chapter:"5",number:"5-19",text_en:"A control bus with eight wires can define ________ operations.",text_zh:"具有八條線的控制匯流排可以定義 ________ 種操作。",options:[{key:"a",text_en:"16",text_zh:"16"},{key:"b",text_en:"256",text_zh:"256"},{key:"c",text_en:"512",text_zh:"512"},{key:"d",text_en:"8",text_zh:"8"}],answer:"b",explanation_zh:"控制匯流排的線數決定了可以傳遞的控制信號種類。有 $n$ 條線的控制匯流排可以定義 $2^n$ 種不同的操作。因此，八條線可以定義 $2^8 = 256$ 種操作。"},{id:"5.20",chapter:"5",number:"5-20",text_en:"A ________ controller is a high-speed serial interface that transfers data in packets.",text_zh:"________ 控制器是一種高速串行接口，以封包形式傳輸數據。",options:[{key:"a",text_en:"USB",text_zh:"USB"},{key:"b",text_en:"FireWire",text_zh:"火線"},{key:"c",text_en:"USB and FireWire",text_zh:"USB 和火線"},{key:"d",text_en:"SCSI",text_zh:"SCSI"}],answer:"c",explanation_zh:"USB (Universal Serial Bus) 和 FireWire (IEEE 1394) 都是高速的序列傳輸介面，它們以封包（packets）的形式傳輸資料，並支援熱插拔。"},{id:"5.21",chapter:"5",number:"5-21",text_en:"The three steps in the running of a program on a computer are performed in the specific order ________.",text_zh:"在電腦上運行程式的三個步驟按特定順序 ________ 執行。",options:[{key:"a",text_en:"decode, execute, and fetch",text_zh:"解碼、執行和提取"},{key:"b",text_en:"fetch, decode, and execute",text_zh:"提取、解碼和執行"},{key:"c",text_en:"decode, fetch, and execute",text_zh:"解碼、提取和執行"},{key:"d",text_en:"fetch, execute, and decode",text_zh:"提取、執行和解碼"}],answer:"b",explanation_zh:"CPU 執行一個指令的週期（machine cycle）包含三個主要步驟：提取（fetch）指令、解碼（decode）指令，以及執行（execute）指令。"},{id:"5.22",chapter:"5",number:"5-22",text_en:"In the ________ method for synchronizing the operation of the CPU with an I/O device, the I/O device informs the CPU when it is ready for data transfer.",text_zh:"在同步 CPU 與 I/O 設備操作的 ________ 方法中，I/O 設備在準備好進行數據傳輸時通知 CPU。",options:[{key:"a",text_en:"interrupt-driven I/O",text_zh:"中斷驅動 I/O"},{key:"b",text_en:"DMA",text_zh:"直接記憶體存取"},{key:"c",text_en:"isolated I/O",text_zh:"獨立 I/O"},{key:"d",text_en:"programmed I/O",text_zh:"程式控制 I/O"}],answer:"a",explanation_zh:"在中斷驅動 I/O (interrupt-driven I/O) 模式中，CPU 在發出 I/O 命令後可以繼續執行其他任務。當 I/O 設備完成操作並準備好傳輸資料時，會發送一個中斷信號來通知 CPU。"},{id:"5.23",chapter:"5",number:"5-23",text_en:"In the ________ method for synchronizing the operation of the CPU with an I/O device, the CPU is idle until the I/O operation is finished.",text_zh:"在同步 CPU 與 I/O 設備操作的 ________ 方法中，CPU 處於閒置狀態，直到 I/O 操作完成。",options:[{key:"a",text_en:"interrupt-driven I/O",text_zh:"中斷驅動 I/O"},{key:"b",text_en:"DMA",text_zh:"直接記憶體存取"},{key:"c",text_en:"isolated I/O",text_zh:"獨立 I/O"},{key:"d",text_en:"programmed I/O",text_zh:"程式控制 I/O"}],answer:"d",explanation_zh:"在程式控制 I/O (programmed I/O) 模式中，CPU 會不斷地檢查 I/O 設備的狀態，直到設備準備好為止。在這個等待過程中，CPU 處於閒置狀態，無法執行其他任務，效率較低。"},{id:"5.24",chapter:"5",number:"5-24",text_en:"In the ________ method for synchronizing the operation of the CPU with an I/O device, a large block of data can be passed from an I/O device to memory directly.",text_zh:"在同步 CPU 與 I/O 設備操作的 ________ 方法中，大塊數據可以直接從 I/O 設備傳遞到記憶體。",options:[{key:"a",text_en:"interrupt-driven I/O",text_zh:"中斷驅動 I/O"},{key:"b",text_en:"DMA",text_zh:"直接記憶體存取"},{key:"c",text_en:"isolated I/O",text_zh:"獨立 I/O"},{key:"d",text_en:"programmed I/O",text_zh:"程式控制 I/O"}],answer:"b",explanation_zh:"DMA (Direct Memory Access) 允許 I/O 設備在 DMA 控制器的協助下，直接與主記憶體交換資料，而不需要 CPU 的介入。這非常適合大量資料的傳輸，可以大大提升效率。"}],x=[{id:"6.1",chapter:"6",number:"6-1",text_en:"The TCP/IP model has ________ layers.",text_zh:"TCP/IP 模型有 ________ 層。",options:[{key:"a",text_en:"six",text_zh:"六"},{key:"b",text_en:"five",text_zh:"五"},{key:"c",text_en:"eight",text_zh:"八"},{key:"d",text_en:"seven",text_zh:"七"}],answer:"b",explanation_zh:"TCP/IP 模型通常被劃分為五個層次（從下到上）：實體層、資料連結層、網路層、傳輸層和應用層。有時也會看到將實體層和資料連結層合併為網路介面層的四層模型。"},{id:"6.2",chapter:"6",number:"6-2",text_en:"The ________ layer of the TCP/IP protocol suite provides services for end users.",text_zh:"TCP/IP 協定套件的 ________ 層為終端使用者提供服務。",options:[{key:"a",text_en:"transport",text_zh:"傳輸層"},{key:"b",text_en:"data-link",text_zh:"資料連結層"},{key:"c",text_en:"physical",text_zh:"實體層"},{key:"d",text_en:"application",text_zh:"應用層"}],answer:"d",explanation_zh:"應用層（application layer）是 TCP/IP 模型的最高層，它直接為終端使用者的應用程式提供網路服務，例如 HTTP（網頁瀏覽）、FTP（檔案傳輸）、SMTP（電子郵件）等。"},{id:"6.3",chapter:"6",number:"6-3",text_en:"The ________ layer of the TCP/IP protocol suite transmits a bit stream over a physical medium.",text_zh:"TCP/IP 協定套件的 ________ 層透過實體媒介傳輸位元流。",options:[{key:"a",text_en:"data-link",text_zh:"資料連結層"},{key:"b",text_en:"physical",text_zh:"實體層"},{key:"c",text_en:"transport",text_zh:"傳輸層"},{key:"d",text_en:"network",text_zh:"網路層"}],answer:"b",explanation_zh:"實體層（physical layer）是 TCP/IP 模型的最底層，負責在實體媒介（如電纜、光纖）上傳輸原始的位元流（bit stream）。"},{id:"6.4",chapter:"6",number:"6-4",text_en:"The ________ layer of the TCP/IP protocol suite is responsible for node-to-node delivery of a frame between two adjacent nodes.",text_zh:"TCP/IP 協定套件的 ________ 層負責在兩個相鄰節點之間進行節點到節點的訊框傳遞。",options:[{key:"a",text_en:"network",text_zh:"網路層"},{key:"b",text_en:"transport",text_zh:"傳輸層"},{key:"c",text_en:"session",text_zh:"會話層"},{key:"d",text_en:"data-link",text_zh:"資料連結層"}],answer:"d",explanation_zh:"資料連結層（data-link layer）負責將網路層的封包（packet）封裝成訊框（frame），並在兩個直接相連的節點之間（hop-to-hop 或 node-to-node）進行可靠的傳輸。"},{id:"6.5",chapter:"6",number:"6-5",text_en:"The ________ layer of the TCP/IP protocol suite is responsible for source-to-destination delivery of the entire message.",text_zh:"TCP/IP 協定套件的 ________ 層負責整個訊息的來源到目的地傳遞。",options:[{key:"a",text_en:"network",text_zh:"網路層"},{key:"b",text_en:"transport",text_zh:"傳輸層"},{key:"c",text_en:"session",text_zh:"會話層"},{key:"d",text_en:"data-link",text_zh:"資料連結層"}],answer:"a",explanation_zh:"網路層（network layer）負責將封包從來源主機傳送到目的主機，實現主機到主機（host-to-host）或來源到目的地（source-to-destination）的傳遞。它處理路由和邏輯定址（IP位址）。"},{id:"6.6",chapter:"6",number:"6-6",text_en:"What is the domain name in the email address kayla@nasa.gov?",text_zh:"電子郵件地址 kayla@nasa.gov 中的網域名稱是什麼？",options:[{key:"a",text_en:"kayla@nasa.gov",text_zh:"kayla@nasa.gov"},{key:"b",text_en:"kayla",text_zh:"kayla"},{key:"c",text_en:"gov",text_zh:"gov"},{key:"d",text_en:"nasa.gov",text_zh:"nasa.gov"}],answer:"d",explanation_zh:"在電子郵件地址中，@ 符號後面的部分是網域名稱（domain name），它指定了郵件伺服器所在的網路域。在此例中為 nasa.gov。"},{id:"6.7",chapter:"6",number:"6-7",text_en:"Which physical topology uses a hub or switch?",text_zh:"哪種實體拓撲使用集線器或交換器？",options:[{key:"a",text_en:"ring",text_zh:"環狀"},{key:"b",text_en:"bus",text_zh:"匯流排"},{key:"c",text_en:"bus and ring",text_zh:"匯流排和環狀"},{key:"d",text_en:"star",text_zh:"星狀"}],answer:"d",explanation_zh:"星狀拓撲（star topology）是目前最常見的區域網路拓撲，所有設備都連接到一個中心的節點，如集線器（hub）或交換器（switch）。"},{id:"6.8",chapter:"6",number:"6-8",text_en:"IP addresses are currently ________ bits in length.",text_zh:"目前的 IP 位址長度為 ________ 位元。",options:[{key:"a",text_en:"8",text_zh:"8"},{key:"b",text_en:"4",text_zh:"4"},{key:"c",text_en:"40",text_zh:"40"},{key:"d",text_en:"32",text_zh:"32"}],answer:"d",explanation_zh:"目前廣泛使用的 IPv4 (Internet Protocol version 4) 位址由 32 位元組成，通常寫成四個用點分隔的十進位數（例如 192.168.1.1）。"},{id:"6.9",chapter:"6",number:"6-9",text_en:"________ protocol(s) is one of the protocols in the transport layer.",text_zh:"________ 協定是傳輸層中的協定之一。",options:[{key:"a",text_en:"Only UDP",text_zh:"僅 UDP"},{key:"b",text_en:"Only TCP",text_zh:"僅 TCP"},{key:"c",text_en:"TCP, UDP, and SCTP",text_zh:"TCP、UDP 和 SCTP"},{key:"d",text_en:"Only SCTP",text_zh:"僅 SCTP"}],answer:"c",explanation_zh:"傳輸層（transport layer）負責提供端對端（end-to-end）的通訊服務。主要的協定有 TCP (提供可靠、面向連接的服務)、UDP (提供不可靠、無連接的服務) 和 SCTP (Stream Control Transmission Protocol)。"},{id:"6.10",chapter:"6",number:"6-10",text_en:"________ is a protocol for file transfer.",text_zh:"________ 是一種用於檔案傳輸的協定。",options:[{key:"a",text_en:"SMTP",text_zh:"SMTP"},{key:"b",text_en:"FTP",text_zh:"FTP"},{key:"c",text_en:"HTTP",text_zh:"HTTP"},{key:"d",text_en:"TELNET",text_zh:"TELNET"}],answer:"b",explanation_zh:"FTP (File Transfer Protocol) 是一個專門用於在網路上進行檔案傳輸的應用層協定。"},{id:"6.11",chapter:"6",number:"6-11",text_en:"________ is a protocol for email services.",text_zh:"________ 是一種用於電子郵件服務的協定。",options:[{key:"a",text_en:"SMTP",text_zh:"SMTP"},{key:"b",text_en:"FTP",text_zh:"FTP"},{key:"c",text_en:"HTTP",text_zh:"HTTP"},{key:"d",text_en:"TELNET",text_zh:"TELNET"}],answer:"a",explanation_zh:"SMTP (Simple Mail Transfer Protocol) 是用於傳送電子郵件的標準應用層協定。"},{id:"6.12",chapter:"6",number:"6-12",text_en:"________ is a protocol for accessing and transferring documents on the WWW.",text_zh:"________ 是用於在全球資訊網上存取和傳輸文件的協定。",options:[{key:"a",text_en:"SMTP",text_zh:"SMTP"},{key:"b",text_en:"FTP",text_zh:"FTP"},{key:"c",text_en:"HTTP",text_zh:"HTTP"},{key:"d",text_en:"TELNET",text_zh:"TELNET"}],answer:"c",explanation_zh:"HTTP (Hypertext Transfer Protocol) 是全球資訊網（WWW）的基礎，用於傳輸超文件（如 HTML 頁面）的應用層協定。"}],o=[{id:"7.1",chapter:"7",number:"7-1",text_en:"________ is a program that facilitates the execution of other programs.",text_zh:"________ 是一個促進其他程式執行的程式。",options:[{key:"a",text_en:"An operating system",text_zh:"作業系統"},{key:"b",text_en:"An application program",text_zh:"應用程式"},{key:"c",text_en:"Hardware",text_zh:"硬體"},{key:"d",text_en:"A queue",text_zh:"佇列"}],answer:"a",explanation_zh:"作業系統（Operating System）是一種系統軟體，它管理電腦硬體與軟體資源，並為電腦程式提供通用服務。"},{id:"7.2",chapter:"7",number:"7-2",text_en:"________ supervises the activity of each component in a computer system.",text_zh:"________ 監管電腦系統中每個元件的活動。",options:[{key:"a",text_en:"An operating system",text_zh:"作業系統"},{key:"b",text_en:"An application program",text_zh:"應用程式"},{key:"c",text_en:"Hardware",text_zh:"硬體"},{key:"d",text_en:"A queue",text_zh:"佇列"}],answer:"a",explanation_zh:"作業系統的核心功能之一就是作為資源管理器，監管並協調所有硬體元件（如CPU、記憶體、I/O設備）的活動。"},{id:"7.3",chapter:"7",number:"7-3",text_en:"Multi-programming requires a ________ operating-system.",text_zh:"多重程式設計需要 ________ 作業系統。",options:[{key:"a",text_en:"batch",text_zh:"批次"},{key:"b",text_en:"distributed",text_zh:"分散式"},{key:"c",text_en:"time-sharing",text_zh:"分時"},{key:"d",text_en:"parallel",text_zh:"平行"}],answer:"c",explanation_zh:"多重程式設計（Multi-programming）的核心是讓多個程式同時存在於記憶體中，並透過CPU排程快速切換執行。分時（Time-sharing）作業系統是實現此目標的一種關鍵技術，它讓每個程式輪流使用CPU一小段時間。"},{id:"7.4",chapter:"7",number:"7-4",text_en:"________ is multi-programming with swapping.",text_zh:"________ 是帶有交換（swapping）的多重程式設計。",options:[{key:"a",text_en:"Partitioning",text_zh:"分割"},{key:"b",text_en:"Queuing",text_zh:"佇列"},{key:"c",text_en:"Paging",text_zh:"分頁"},{key:"d",text_en:"Demand paging",text_zh:"請求分頁"}],answer:"d",explanation_zh:"交換（Swapping）是指將整個行程（process）移出主記憶體到次級儲存體。請求分頁（Demand paging）是一種虛擬記憶體技術，它只在需要時才將頁面（page）從磁碟載入記憶體，這是一種更有效率的交換形式。"},{id:"7.5",chapter:"7",number:"7-5",text_en:"________ is multi-programming without swapping.",text_zh:"________ 是不帶有交換（swapping）的多重程式設計。",options:[{key:"a",text_en:"Partitioning",text_zh:"分割"},{key:"b",text_en:"Queuing",text_zh:"佇列"},{key:"c",text_en:"Virtual memory",text_zh:"虛擬記憶體"},{key:"d",text_en:"Demand paging",text_zh:"請求分頁"}],answer:"a",explanation_zh:"分割（Partitioning）是一種早期的記憶體管理技術，它將記憶體劃分為多個固定或動態的區域，每個程式完全載入到一個分割區中執行。在此模型中，程式一旦載入就不會被交換出去，直到執行完畢。"},{id:"7.6",chapter:"7",number:"7-6",text_en:"In ________, only one program can reside in memory for execution.",text_zh:"在 ________ 中，記憶體中一次只能有一個程式駐留以供執行。",options:[{key:"a",text_en:"mono-programming",text_zh:"單道程式設計"},{key:"b",text_en:"paging",text_zh:"分頁"},{key:"c",text_en:"multi-programming",text_zh:"多重程式設計"},{key:"d",text_en:"partitioning",text_zh:"分割"}],answer:"a",explanation_zh:"單道程式設計（Mono-programming）是最早期的作業系統模型，記憶體中一次只存放一個使用者程式，CPU完全被該程式獨佔直到結束。"},{id:"7.7",chapter:"7",number:"7-7",text_en:"________ is a multi-programming method in which multiple programs are entirely in memory with each program occupying a contiguous space.",text_zh:"________ 是一種多重程式設計方法，其中多個程式完全存在於記憶體中，每個程式佔用一個連續的空間。",options:[{key:"a",text_en:"Partitioning",text_zh:"分割"},{key:"b",text_en:"demand segmentation",text_zh:"請求分段"},{key:"c",text_en:"paging",text_zh:"分頁"},{key:"d",text_en:"demand paging",text_zh:"請求分頁"}],answer:"a",explanation_zh:"分割（Partitioning）是將記憶體劃分為連續的區塊，並將整個程式載入其中一個區塊。這是最早期的多重程式設計記憶體管理方式。"},{id:"7.8",chapter:"7",number:"7-8",text_en:"In paging, a program is divided into equally sized sections called ________.",text_zh:"在分頁技術中，程式被劃分為大小相等的區塊，稱為 ________。",options:[{key:"a",text_en:"pages",text_zh:"頁面"},{key:"b",text_en:"partitions",text_zh:"分割區"},{key:"c",text_en:"frames",text_zh:"頁框"},{key:"d",text_en:"segments",text_zh:"分段"}],answer:"a",explanation_zh:"在分頁（Paging）記憶體管理中，程式的邏輯位址空間被劃分為固定大小的區塊，稱為頁面（pages）。實體記憶體則被劃分為同樣大小的頁框（frames）。"},{id:"7.9",chapter:"7",number:"7-9",text_en:"In ________, the program can be divided into differently sized sections.",text_zh:"在 ________ 中，程式可以被劃分為不同大小的區塊。",options:[{key:"a",text_en:"partitioning",text_zh:"分割"},{key:"b",text_en:"demand segmentation",text_zh:"請求分段"},{key:"c",text_en:"paging",text_zh:"分頁"},{key:"d",text_en:"demand paging",text_zh:"請求分頁"}],answer:"b",explanation_zh:"分段（Segmentation）是一種記憶體管理技術，它將程式的邏輯位址空間劃分為多個大小可變的段（segments），每個段對應程式的一個邏輯單元（如主程式、子程式、堆疊等）。請求分段是其與虛擬記憶體結合的技術。"},{id:"7.10",chapter:"7",number:"7-10",text_en:"In ________, the program can be divided into equally sized sections called pages, but the pages need not be in memory at the same time for execution.",text_zh:"在 ________ 中，程式可以被劃分為大小相等的稱為頁面的區塊，但執行時這些頁面不必同時都在記憶體中。",options:[{key:"a",text_en:"partitioning",text_zh:"分割"},{key:"b",text_en:"demand segmentation",text_zh:"請求分段"},{key:"c",text_en:"paging",text_zh:"分頁"},{key:"d",text_en:"demand paging",text_zh:"請求分頁"}],answer:"d",explanation_zh:"請求分頁（Demand paging）是虛擬記憶體的核心技術。它允許程式在只有部分頁面載入主記憶體的情況下執行，當需要用到不在記憶體中的頁面時，再從磁碟載入。"},{id:"7.11",chapter:"7",number:"7-11",text_en:"A process in the ________ state can go to either the ready, terminated, or waiting states.",text_zh:"處於 ________ 狀態的行程可以轉換到就緒、終止或等待狀態。",options:[{key:"a",text_en:"hold",text_zh:"保持"},{key:"b",text_en:"hold or running",text_zh:"保持或執行中"},{key:"c",text_en:"virtual",text_zh:"虛擬"},{key:"d",text_en:"running",text_zh:"執行中"}],answer:"d",explanation_zh:"處於執行中（running）狀態的行程：1. 時間片用完會回到就緒（ready）狀態；2. 執行完畢會進入終止（terminated）狀態；3. 請求 I/O 操作會進入等待（waiting）狀態。"},{id:"7.12",chapter:"7",number:"7-12",text_en:"A process in the ready state goes to the running state when ________.",text_zh:"處於就緒狀態的行程在 ________ 時進入執行狀態。",options:[{key:"a",text_en:"it requests I/O",text_zh:"它請求 I/O"},{key:"b",text_en:"it gets access to the CPU",text_zh:"它獲得 CPU 的存取權"},{key:"c",text_en:"it finishes running",text_zh:"它完成執行"},{key:"d",text_en:"it enters memory",text_zh:"它進入記憶體"}],answer:"b",explanation_zh:"行程排程器（Scheduler）會從就緒佇列（ready queue）中選擇一個行程，並分配 CPU 給它，此時該行程的狀態就從就緒（ready）轉為執行（running）。"},{id:"7.13",chapter:"7",number:"7-13",text_en:"A program becomes a ________ when it is selected by the operating system and brought to the hold state.",text_zh:"當一個程式被作業系統選中並帶到保持狀態時，它就變成了一個 ________。",options:[{key:"a",text_en:"job",text_zh:"工作"},{key:"b",text_en:"partition",text_zh:"分割區"},{key:"c",text_en:"process",text_zh:"行程"},{key:"d",text_en:"deadlock",text_zh:"死結"}],answer:"a",explanation_zh:"在批次處理系統中，使用者提交的程式首先被視為一個工作（job）。作業系統的工作排程器會從工作池中選取工作，準備將其載入記憶體執行。"},{id:"7.14",chapter:"7",number:"7-14",text_en:"Every process is ________.",text_zh:"每個行程都是 ________。",options:[{key:"a",text_en:"only a job",text_zh:"只是一個工作"},{key:"b",text_en:"a job and a program",text_zh:"一個工作和一個程式"},{key:"c",text_en:"only a program",text_zh:"只是一個程式"},{key:"d",text_en:"only a partition",text_zh:"只是一個分割區"}],answer:"b",explanation_zh:"一個行程（process）是一個正在執行中的程式實例。它源自於一個程式碼（program），並由作業系統當作一個工作（job）來管理其資源和執行。"},{id:"7.15",chapter:"7",number:"7-15",text_en:"The ________ scheduler creates a process from a job and changes a process back to a job.",text_zh:"________ 排程器從工作中創建一個行程，並將行程變回工作。",options:[{key:"a",text_en:"job",text_zh:"工作"},{key:"b",text_en:"queue",text_zh:"佇列"},{key:"c",text_en:"process",text_zh:"行程"},{key:"d",text_en:"virtual",text_zh:"虛擬"}],answer:"a",explanation_zh:"工作排程器（Job scheduler），也稱為長期排程器，負責從工作池中選擇工作，為其分配資源並創建行程，將其放入就緒佇列。當行程結束時，它也負責釋放資源。"},{id:"7.16",chapter:"7",number:"7-16",text_en:"The ________ scheduler moves a process from one process state to another.",text_zh:"________ 排程器將行程從一個狀態移動到另一個狀態。",options:[{key:"a",text_en:"job",text_zh:"工作"},{key:"b",text_en:"queue",text_zh:"佇列"},{key:"c",text_en:"process",text_zh:"行程"},{key:"d",text_en:"virtual",text_zh:"虛擬"}],answer:"c",explanation_zh:"行程排程器（Process scheduler），也稱為短期排程器或 CPU 排程器，負責管理行程在就緒、執行和等待等狀態之間的轉換。"},{id:"7.17",chapter:"7",number:"7-17",text_en:"To prevent ________, an operating system can put resource restrictions on processes.",text_zh:"為了防止 ________，作業系統可以對行程施加資源限制。",options:[{key:"a",text_en:"starvation",text_zh:"饑餓"},{key:"b",text_en:"deadlock",text_zh:"死結"},{key:"c",text_en:"synchronization",text_zh:"同步"},{key:"d",text_en:"paging",text_zh:"分頁"}],answer:"b",explanation_zh:"死結（Deadlock）是指兩個或多個行程互相等待對方釋放資源而導致所有行程都無法繼續執行的情況。作業系統可以透過資源分配策略來預防或避免死結的發生。"},{id:"7.18",chapter:"7",number:"7-18",text_en:"________ can occur if a process has too many resource restrictions.",text_zh:"如果一個行程有太多的資源限制，可能會發生 ________。",options:[{key:"a",text_en:"Starvation",text_zh:"饑餓"},{key:"b",text_en:"Deadlock",text_zh:"死結"},{key:"c",text_en:"Synchronization",text_zh:"同步"},{key:"d",text_en:"Paging",text_zh:"分頁"}],answer:"a",explanation_zh:"饑餓（Starvation）是指一個行程因為優先權過低或其他原因，長時間無法獲得執行所需的資源（如CPU時間），導致其一直無法向前推進。過多的限制可能導致這種情況。"},{id:"7.19",chapter:"7",number:"7-19",text_en:"The ________ manager is responsible for archiving and backup.",text_zh:"________ 管理器負責存檔和備份。",options:[{key:"a",text_en:"memory",text_zh:"記憶體"},{key:"b",text_en:"file",text_zh:"檔案"},{key:"c",text_en:"process",text_zh:"行程"},{key:"d",text_en:"device",text_zh:"設備"}],answer:"b",explanation_zh:"檔案管理器（File manager）是作業系統的一部分，負責管理檔案系統，包括檔案的創建、刪除、讀寫，以及存檔（archiving）和備份（backup）等操作。"},{id:"7.20",chapter:"7",number:"7-20",text_en:"The ________ manager is responsible for access to I/O devices.",text_zh:"________ 管理器負責對 I/O 設備的存取。",options:[{key:"a",text_en:"memory",text_zh:"記憶體"},{key:"b",text_en:"file",text_zh:"檔案"},{key:"c",text_en:"process",text_zh:"行程"},{key:"d",text_en:"device",text_zh:"設備"}],answer:"d",explanation_zh:"設備管理器（Device manager）是作業系統的一部分，負責管理所有的 I/O 設備，控制設備的存取、處理中斷，並提供統一的介面給上層軟體。"}],i=[{id:"8.1",chapter:"8",number:"8-1",text_en:"________ is a step-by-step method for solving a problem or doing a task.",text_zh:"________ 是解決問題或完成任務的逐步方法。",options:[{key:"a",text_en:"A construct",text_zh:"建構"},{key:"b",text_en:"An iteration",text_zh:"迭代"},{key:"c",text_en:"A recursion",text_zh:"遞迴"},{key:"d",text_en:"An algorithm",text_zh:"演算法"}],answer:"d",explanation_zh:"演算法（Algorithm）是一組明確定義的、有限的步驟序列，用於解決特定問題或執行計算。"},{id:"8.2",chapter:"8",number:"8-2",text_en:"There are ________ basic constructs in computer-science.",text_zh:"電腦科學中有 ________ 種基本建構。",options:[{key:"a",text_en:"one",text_zh:"一"},{key:"b",text_en:"three",text_zh:"三"},{key:"c",text_en:"two",text_zh:"二"},{key:"d",text_en:"four",text_zh:"四"}],answer:"b",explanation_zh:"結構化程式設計的三種基本建構是：循序（sequence）、選擇（decision/selection）和重複（repetition/iteration）。"},{id:"8.3",chapter:"8",number:"8-3",text_en:"The ________ construct tests a condition.",text_zh:"________ 建構測試一個條件。",options:[{key:"a",text_en:"sequence",text_zh:"循序"},{key:"b",text_en:"repetition",text_zh:"重複"},{key:"c",text_en:"decision",text_zh:"選擇"},{key:"d",text_en:"flow",text_zh:"流程"}],answer:"c",explanation_zh:"選擇（Decision）建構（例如 if-then-else）會根據一個條件的真假來決定執行哪一個程式碼區塊。"},{id:"8.4",chapter:"8",number:"8-4",text_en:"The ________ construct uses a set of actions one after another.",text_zh:"________ 建構將一組動作一個接一個地執行。",options:[{key:"a",text_en:"sequence",text_zh:"循序"},{key:"b",text_en:"repetition",text_zh:"重複"},{key:"c",text_en:"decision",text_zh:"選擇"},{key:"d",text_en:"flow",text_zh:"流程"}],answer:"a",explanation_zh:"循序（Sequence）建構是指程式碼中的指令按照它們出現的順序，從上到下依次執行。"},{id:"8.5",chapter:"8",number:"8-5",text_en:"The ________ construct handles repeated actions.",text_zh:"________ 建構處理重複的動作。",options:[{key:"a",text_en:"sequence",text_zh:"循序"},{key:"b",text_en:"repetition",text_zh:"重複"},{key:"c",text_en:"decision",text_zh:"選擇"},{key:"d",text_en:"flow",text_zh:"流程"}],answer:"b",explanation_zh:"重複（Repetition）建構（例如 while 或 for 迴圈）允許一個程式碼區塊被重複執行多次。"},{id:"8.6",chapter:"8",number:"8-6",text_en:"________ is a pictorial representation of an algorithm.",text_zh:"________ 是演算法的圖形表示。",options:[{key:"a",text_en:"A UML diagram",text_zh:"UML 圖"},{key:"b",text_en:"Pseudocode",text_zh:"偽代碼"},{key:"c",text_en:"A program",text_zh:"程式"},{key:"d",text_en:"An algorithm",text_zh:"演算法"}],answer:"a",explanation_zh:"UML（統一建模語言）圖，特別是活動圖（Activity Diagram），可以用來圖形化地表示演算法的流程。更傳統的說法是流程圖（Flowchart）。"},{id:"8.7",chapter:"8",number:"8-7",text_en:"________ is an English-language-like representation of code.",text_zh:"________ 是一種近似英語的程式碼表示法。",options:[{key:"a",text_en:"A UML diagram",text_zh:"UML 圖"},{key:"b",text_en:"Pseudocode",text_zh:"偽代碼"},{key:"c",text_en:"A program",text_zh:"程式"},{key:"d",text_en:"An algorithm",text_zh:"演算法"}],answer:"b",explanation_zh:"偽代碼（Pseudocode）是一種非正式的高階語言，用於在編寫實際程式碼之前，描述演算法的邏輯和步驟。"},{id:"8.8",chapter:"8",number:"8-8",text_en:"________ is a basic algorithm that adds a list of numbers.",text_zh:"________ 是將一列數字相加的基本演算法。",options:[{key:"a",text_en:"Summation",text_zh:"總和"},{key:"b",text_en:"Smallest",text_zh:"最小值"},{key:"c",text_en:"Product",text_zh:"乘積"},{key:"d",text_en:"Largest",text_zh:"最大值"}],answer:"a",explanation_zh:"總和（Summation）演算法遍歷一個數字列表，並將所有數字累加起來得到總和。"},{id:"8.9",chapter:"8",number:"8-9",text_en:"________ is a basic algorithm that multiplies a list of numbers.",text_zh:"________ 是將一列數字相乘的基本演算法。",options:[{key:"a",text_en:"Summation",text_zh:"總和"},{key:"b",text_en:"Smallest",text_zh:"最小值"},{key:"c",text_en:"Product",text_zh:"乘積"},{key:"d",text_en:"Largest",text_zh:"最大值"}],answer:"c",explanation_zh:"乘積（Product）演算法遍歷一個數字列表，並將所有數字累乘起來得到總乘積。"},{id:"8.10",chapter:"8",number:"8-10",text_en:"________ is a basic algorithm that arranges data according to its value.",text_zh:"________ 是根據數值排列資料的基本演算法。",options:[{key:"a",text_en:"Inquiry",text_zh:"查詢"},{key:"b",text_en:"Searching",text_zh:"搜尋"},{key:"c",text_en:"Sorting",text_zh:"排序"},{key:"d",text_en:"Recursion",text_zh:"遞迴"}],answer:"c",explanation_zh:"排序（Sorting）演算法是將一組資料（如數字或字串）按照特定的順序（如由小到大或字母順序）重新排列的过程。"},{id:"8.11",chapter:"8",number:"8-11",text_en:"The items are divided into two lists (sorted and unsorted) ________ sort.",text_zh:"在 ________ 排序中，項目被分為兩個列表（已排序和未排序）。",options:[{key:"a",text_en:"only in a selection",text_zh:"僅在選擇排序中"},{key:"b",text_en:"only in an insertion",text_zh:"僅在插入排序中"},{key:"c",text_en:"only in a bubble",text_zh:"僅在氣泡排序中"},{key:"d",text_en:"in selection, bubble, or insertion",text_zh:"在選擇、氣泡或插入排序中"}],answer:"d",explanation_zh:"選擇排序、氣泡排序和插入排序這三種基本的排序演算法，其核心思想都是將列表視為已排序和未排序兩部分，並逐步將未排序部分的元素移動到已排序部分。"},{id:"8.12",chapter:"8",number:"8-12",text_en:"In ________ sort, the item that goes into the sorted list is always the first item in the unsorted list.",text_zh:"在 ________ 排序中，進入已排序列表的項目總是未排序列表中的第一個項目。",options:[{key:"a",text_en:"selection",text_zh:"選擇"},{key:"b",text_en:"insertion",text_zh:"插入"},{key:"c",text_en:"bubble",text_zh:"氣泡"},{key:"d",text_en:"every",text_zh:"每種"}],answer:"b",explanation_zh:"在插入排序（Insertion sort）中，我們依序從未排序部分取出第一個元素，然後在已排序部分中找到合適的位置插入它。"},{id:"8.13",chapter:"8",number:"8-13",text_en:"In ________ sort, the smallest item from the unsorted list is swapped with the item at the beginning of the unsorted list.",text_zh:"在 ________ 排序中，從未排序列表中找到的最小項目會與未排序列表開頭的項目交換。",options:[{key:"a",text_en:"selection",text_zh:"選擇"},{key:"b",text_en:"insertion",text_zh:"插入"},{key:"c",text_en:"bubble",text_zh:"氣泡"},{key:"d",text_en:"every",text_zh:"每種"}],answer:"a",explanation_zh:"在選擇排序（Selection sort）中，每一輪都會從當前的未排序部分找到最小（或最大）的元素，然後將它與未排序部分的第一个元素交換位置。"},{id:"8.14",chapter:"8",number:"8-14",text_en:"In ________ sort, the smallest item moves to the beginning of the unsorted list. There is no one-to-one swapping.",text_zh:"在 ________ 排序中，最小的項目移動到未排序列表的開頭。沒有一對一的交換。",options:[{key:"a",text_en:"selection",text_zh:"選擇"},{key:"b",text_en:"insertion",text_zh:"插入"},{key:"c",text_en:"bubble",text_zh:"氣泡"},{key:"d",text_en:"every",text_zh:"每種"}],answer:"c",explanation_zh:"在氣泡排序（Bubble sort）中，透過重複比較相鄰的元素並交換它們（如果順序錯誤），較小（或較大）的元素會像氣泡一樣逐漸浮到列表的頂端。這個過程涉及多次相鄰交換，而不是一次性的交換到開頭。"},{id:"8.15",chapter:"8",number:"8-15",text_en:"________ is a basic algorithm in which we want to find the location of a target in a list of items.",text_zh:"________ 是一種基本演算法，我們想在項目列表中找到目標的位置。",options:[{key:"a",text_en:"Sorting",text_zh:"排序"},{key:"b",text_en:"Product",text_zh:"乘積"},{key:"c",text_en:"Searching",text_zh:"搜尋"},{key:"d",text_en:"Summation",text_zh:"總和"}],answer:"c",explanation_zh:"搜尋（Searching）演算法用於在資料集合中查找滿足特定條件的項目。"},{id:"8.16",chapter:"8",number:"8-16",text_en:"We use a ________ search for an unordered list.",text_zh:"我們對未排序的列表使用 ________ 搜尋。",options:[{key:"a",text_en:"sequential",text_zh:"循序"},{key:"b",text_en:"bubble",text_zh:"氣泡"},{key:"c",text_en:"binary",text_zh:"二元"},{key:"d",text_en:"insertion",text_zh:"插入"}],answer:"a",explanation_zh:"循序搜尋（Sequential search）從列表的開頭逐一檢查每個元素，直到找到目標或遍歷完整個列表。它適用於任何列表，無論是否排序。"},{id:"8.17",chapter:"8",number:"8-17",text_en:"We use a ________ search for an ordered list.",text_zh:"我們對已排序的列表使用 ________ 搜尋。",options:[{key:"a",text_en:"sequential",text_zh:"循序"},{key:"b",text_en:"bubble",text_zh:"氣泡"},{key:"c",text_en:"binary",text_zh:"二元"},{key:"d",text_en:"insertion",text_zh:"插入"}],answer:"c",explanation_zh:"二元搜尋（Binary search）是一種高效的搜尋演算法，但它要求列表必須是已排序的。它透過反覆將搜尋區間一分為二來快速定位目標。"},{id:"8.18",chapter:"8",number:"8-18",text_en:"________ is a process in which an algorithm calls itself.",text_zh:"________ 是演算法呼叫自身的過程。",options:[{key:"a",text_en:"Insertion",text_zh:"插入"},{key:"b",text_en:"Recursion",text_zh:"遞迴"},{key:"c",text_en:"Searching",text_zh:"搜尋"},{key:"d",text_en:"Iteration",text_zh:"迭代"}],answer:"b",explanation_zh:"遞迴（Recursion）是一種解決問題的方法，其中函式（或演算法）透過呼叫自身來解決問題的較小子實例。"}],h=[{id:"9.1",chapter:"9",number:"9-1",text_en:"The only language understood by computer hardware is a ________ language.",text_zh:"電腦硬體唯一能理解的語言是 ________ 語言。",options:[{key:"a",text_en:"natural",text_zh:"自然"},{key:"b",text_en:"machine",text_zh:"機器"},{key:"c",text_en:"symbolic",text_zh:"符號"},{key:"d",text_en:"high-level",text_zh:"高階"}],answer:"b",explanation_zh:"機器語言（Machine language）是由二進位代碼組成的指令集，是電腦 CPU 可以直接執行的唯一語言。"},{id:"9.2",chapter:"9",number:"9-2",text_en:"C, C++, and Java can be classified as ________ languages.",text_zh:"C、C++ 和 Java 可以歸類為 ________ 語言。",options:[{key:"a",text_en:"natural",text_zh:"自然"},{key:"b",text_en:"machine",text_zh:"機器"},{key:"c",text_en:"symbolic",text_zh:"符號"},{key:"d",text_en:"high-level",text_zh:"高階"}],answer:"d",explanation_zh:"高階語言（High-level languages）使用更接近人類語言的語法，使程式設計更容易，並且需要透過編譯器或直譯器轉換成機器語言才能執行。"},{id:"9.3",chapter:"9",number:"9-3",text_en:"FORTRAN is a(n) ________ language.",text_zh:"FORTRAN 是一種 ________ 語言。",options:[{key:"a",text_en:"object-oriented",text_zh:"物件導向"},{key:"b",text_en:"procedural",text_zh:"程序化"},{key:"c",text_en:"functional",text_zh:"函數式"},{key:"d",text_en:"declarative",text_zh:"宣告式"}],answer:"b",explanation_zh:"FORTRAN 是一種早期的程序化語言（Procedural language），程式由一系列的程序或副程式（subroutines）組成。"},{id:"9.4",chapter:"9",number:"9-4",text_en:"Pascal is a(n) ________ language.",text_zh:"Pascal 是一種 ________ 語言。",options:[{key:"a",text_en:"object-oriented",text_zh:"物件導向"},{key:"b",text_en:"procedural",text_zh:"程序化"},{key:"c",text_en:"functional",text_zh:"函數式"},{key:"d",text_en:"declarative",text_zh:"宣告式"}],answer:"b",explanation_zh:"Pascal 是一種結構化的程序化語言（Procedural language），強調清晰的程式結構和資料結構。"},{id:"9.5",chapter:"9",number:"9-5",text_en:"Java is a(n) ________ language.",text_zh:"Java 是一種 ________ 語言。",options:[{key:"a",text_en:"object-oriented",text_zh:"物件導向"},{key:"b",text_en:"procedural",text_zh:"程序化"},{key:"c",text_en:"functional",text_zh:"函數式"},{key:"d",text_en:"declarative",text_zh:"宣告式"}],answer:"a",explanation_zh:"Java 是一種典型的物件導向（Object-oriented）程式語言，其核心思想是將所有事物都視為「物件」。"},{id:"9.6",chapter:"9",number:"9-6",text_en:"LISP is a(n) ________ language.",text_zh:"LISP 是一種 ________ 語言。",options:[{key:"a",text_en:"object-oriented",text_zh:"物件導向"},{key:"b",text_en:"procedural",text_zh:"程序化"},{key:"c",text_en:"functional",text_zh:"函數式"},{key:"d",text_en:"declarative",text_zh:"宣告式"}],answer:"c",explanation_zh:"LISP 是最早的函數式程式語言（Functional language）之一，它將計算視為數學函式的求值。"},{id:"9.7",chapter:"9",number:"9-7",text_en:"________ is a common language in the business-environment.",text_zh:"________ 是商業環境中常用的語言。",options:[{key:"a",text_en:"COBOL",text_zh:"COBOL"},{key:"b",text_en:"FORTRAN",text_zh:"FORTRAN"},{key:"c",text_en:"C++",text_zh:"C++"},{key:"d",text_en:"C",text_zh:"C"}],answer:"a",explanation_zh:"COBOL（Common Business-Oriented Language）是專為商業資料處理而設計的程式語言，在金融和政府等領域有著悠久的歷史。"},{id:"9.8",chapter:"9",number:"9-8",text_en:"________ is a popular object-oriented language.",text_zh:"________ 是一種流行的物件導向語言。",options:[{key:"a",text_en:"LISP",text_zh:"LISP"},{key:"b",text_en:"FORTRAN",text_zh:"FORTRAN"},{key:"c",text_en:"COBOL",text_zh:"COBOL"},{key:"d",text_en:"Java",text_zh:"Java"}],answer:"d",explanation_zh:"Java 是世界上最流行和廣泛使用的物件導向程式語言之一，其他流行的還有 C++, Python, C# 等。"},{id:"9.9",chapter:"9",number:"9-9",text_en:"A ________ program can be either an application or an applet.",text_zh:"一個 ________ 程式可以是一個應用程式（application）或一個小程式（applet）。",options:[{key:"a",text_en:"Java",text_zh:"Java"},{key:"b",text_en:"FORTRAN",text_zh:"FORTRAN"},{key:"c",text_en:"C++",text_zh:"C++"},{key:"d",text_en:"C",text_zh:"C"}],answer:"a",explanation_zh:"Java Applet 是一種早期技術，允許 Java 程式在網頁瀏覽器中執行。因此，Java 程式可以編寫為獨立的應用程式（application）或嵌入式的 Applet。"},{id:"9.10",chapter:"9",number:"9-10",text_en:"LISP and Scheme are both ________ languages.",text_zh:"LISP 和 Scheme 都是 ________ 語言。",options:[{key:"a",text_en:"object-oriented",text_zh:"物件導向"},{key:"b",text_en:"procedural",text_zh:"程序化"},{key:"c",text_en:"functional",text_zh:"函數式"},{key:"d",text_en:"declarative",text_zh:"宣告式"}],answer:"c",explanation_zh:"Scheme 是 LISP 的一個方言，兩者都是著名且有影響力的函數式程式語言（Functional language）。"},{id:"9.11",chapter:"9",number:"9-11",text_en:"Prolog is an example of a(n) ________ language.",text_zh:"Prolog 是 ________ 語言的一個例子。",options:[{key:"a",text_en:"object-oriented",text_zh:"物件導向"},{key:"b",text_en:"procedural",text_zh:"程序化"},{key:"c",text_en:"functional",text_zh:"函數式"},{key:"d",text_en:"declarative",text_zh:"宣告式"}],answer:"d",explanation_zh:"Prolog 是一種邏輯程式語言，屬於宣告式程式語言（Declarative language）的一種。它描述了要達成什麼目標，而不是如何達成。"}],r=[{id:"10.1",chapter:"10",number:"10-1",text_en:"One phase in system development is ________.",text_zh:"系統開發中的一個階段是 ________。",options:[{key:"a",text_en:"analysis",text_zh:"分析"},{key:"b",text_en:"designing",text_zh:"設計"},{key:"c",text_en:"collecting",text_zh:"收集"},{key:"d",text_en:"application",text_zh:"應用"}],answer:"a",explanation_zh:"傳統的軟體開發生命週期（SDLC）通常包括幾個階段，如需求分析（analysis）、設計（design）、實作（implementation）、測試（testing）和維護（maintenance）。"},{id:"10.2",chapter:"10",number:"10-2",text_en:"Defining the users, requirements, and methods is part of the ________ phase.",text_zh:"定義使用者、需求和方法是 ________ 階段的一部分。",options:[{key:"a",text_en:"analysis",text_zh:"分析"},{key:"b",text_en:"implementation",text_zh:"實作"},{key:"c",text_en:"testing",text_zh:"測試"},{key:"d",text_en:"design",text_zh:"設計"}],answer:"a",explanation_zh:"在需求分析（Analysis）階段，開發團隊會與利害關係人溝通，以確定系統的使用者、功能需求和非功能需求。"},{id:"10.3",chapter:"10",number:"10-3",text_en:"In the system development process, writing the program is part of the ________ phase.",text_zh:"在系統開發過程中，編寫程式是 ________ 階段的一部分。",options:[{key:"a",text_en:"analysis",text_zh:"分析"},{key:"b",text_en:"implementation",text_zh:"實作"},{key:"c",text_en:"testing",text_zh:"測試"},{key:"d",text_en:"design",text_zh:"設計"}],answer:"b",explanation_zh:"在實作（Implementation）階段，開發人員會根據設計文件開始編寫實際的程式碼。"},{id:"10.4",chapter:"10",number:"10-4",text_en:"In the system development process, structure charts are tools used in the ________ phase.",text_zh:"在系統開發過程中，結構圖是在 ________ 階段使用的工具。",options:[{key:"a",text_en:"analysis",text_zh:"分析"},{key:"b",text_en:"implementation",text_zh:"實作"},{key:"c",text_en:"testing",text_zh:"測試"},{key:"d",text_en:"design",text_zh:"設計"}],answer:"d",explanation_zh:"結構圖（Structure charts）是一種用於描繪系統模組結構和模組之間關係的圖表，常用於軟體設計（Design）階段。"},{id:"10.5",chapter:"10",number:"10-5",text_en:"Testing a software system can involve ________ testing.",text_zh:"測試軟體系統可以涉及 ________ 測試。",options:[{key:"a",text_en:"black-box",text_zh:"黑箱"},{key:"b",text_en:"neither black-box nor glass-box",text_zh:"既非黑箱也非玻璃箱"},{key:"c",text_en:"both black-box and glass-box",text_zh:"黑箱和玻璃箱"},{key:"d",text_en:"glass-box",text_zh:"玻璃箱"}],answer:"c",explanation_zh:"軟體測試包含多種類型，其中黑箱測試（Black-box testing）專注於功能，不關心內部實現；而白箱測試（White-box/glass-box testing）則基於程式的內部結構進行測試。完整的測試策略通常兩者都會包含。"},{id:"10.6",chapter:"10",number:"10-6",text_en:"________ is the breaking up of a large project into smaller parts.",text_zh:"________ 是將一個大型專案分解成較小部分的过程。",options:[{key:"a",text_en:"Coupling",text_zh:"耦合"},{key:"b",text_en:"Obsolescence",text_zh:"過時"},{key:"c",text_en:"Modularization",text_zh:"模組化"},{key:"d",text_en:"Incrementing",text_zh:"增量"}],answer:"c",explanation_zh:"模組化（Modularization）是一種軟體設計原則，旨在將複雜的系統分解為獨立、可互換的模組，每個模組負責一項特定的功能。"},{id:"10.7",chapter:"10",number:"10-7",text_en:"________ is a measure of how tightly two modules are bound to each other.",text_zh:"________ 是衡量兩個模組之間緊密程度的指標。",options:[{key:"a",text_en:"Modularity",text_zh:"模組性"},{key:"b",text_en:"Interoperability",text_zh:"互操作性"},{key:"c",text_en:"Cohesion",text_zh:"內聚"},{key:"d",text_en:"Coupling",text_zh:"耦合"}],answer:"d",explanation_zh:"耦合（Coupling）描述了軟體模組之間的相互依賴程度。良好的軟體設計追求低耦合，即模組之間應盡可能獨立。"},{id:"10.8",chapter:"10",number:"10-8",text_en:"________ between modules in a software system must be minimized.",text_zh:"軟體系統中模組之間的 ________ 必須最小化。",options:[{key:"a",text_en:"Coupling",text_zh:"耦合"},{key:"b",text_en:"Neither coupling nor cohesion",text_zh:"既非耦合也非內聚"},{key:"c",text_en:"Both coupling and cohesion",text_zh:"耦合和內聚"},{key:"d",text_en:"Cohesion",text_zh:"內聚"}],answer:"a",explanation_zh:"低耦合（Low coupling）是軟體設計的一個重要目標。它意味著模組之間的依賴性較低，修改一個模組對其他模組的影響較小，從而提高系統的可維護性和可重用性。"},{id:"10.9",chapter:"10",number:"10-9",text_en:"________ between modules in a software system must be maximized.",text_zh:"軟體系統中模組之間的 ________ 必須最大化。",options:[{key:"a",text_en:"Coupling",text_zh:"耦合"},{key:"b",text_en:"Neither coupling nor cohesion",text_zh:"既非耦合也非內聚"},{key:"c",text_en:"Both coupling and cohesion",text_zh:"耦合和內聚"},{key:"d",text_en:"Cohesion",text_zh:"內聚"}],answer:"d",explanation_zh:"高內聚（High cohesion）是軟體設計的另一個重要目標。它意味著一個模組內部的各個元素（如函式、資料）彼此緊密相關，共同完成一個單一、明確的任務。"}],s=[{id:"11.1",chapter:"11",number:"11-1",text_en:"A data structure can be ________.",text_zh:"資料結構可以是 ________。",options:[{key:"a",text_en:"an array, a record, or a linked list",text_zh:"陣列、記錄或鏈結串列"},{key:"b",text_en:"only a record",text_zh:"僅記錄"},{key:"c",text_en:"only a linked list",text_zh:"僅鏈結串列"},{key:"d",text_en:"only an array",text_zh:"僅陣列"}],answer:"a",explanation_zh:"資料結構是組織和儲存資料的方式。陣列、記錄和鏈結串列都是常見的基本資料結構類型。"},{id:"11.2",chapter:"11",number:"11-2",text_en:"An array that consists of just rows and columns is a ________ array.",text_zh:"一個僅由行和列組成的陣列是 ________ 陣列。",options:[{key:"a",text_en:"multidimensional",text_zh:"多維"},{key:"b",text_en:"two-dimensional",text_zh:"二維"},{key:"c",text_en:"three-dimensional",text_zh:"三維"},{key:"d",text_en:"one-dimensional",text_zh:"一維"}],answer:"d",explanation_zh:"這個問題的措辭有歧義。通常，具有行和列的陣列被稱為二維陣列。然而，一維陣列可以被視覺化為單行或單列。鑒於提供的答案是 d，題目可能意指陣列的基本組成單位是行或列，而一個單獨的行或列本身是一維的。"},{id:"11.3",chapter:"11",number:"11-3",text_en:"Each element in a record is called ________.",text_zh:"記錄中的每個元素稱為 ________。",options:[{key:"a",text_en:"a node",text_zh:"節點"},{key:"b",text_en:"an index",text_zh:"索引"},{key:"c",text_en:"a field",text_zh:"欄位"},{key:"d",text_en:"a variable",text_zh:"變數"}],answer:"c",explanation_zh:"記錄（Record）是由一組相關的資料項組成的集合，其中每個資料項稱為一個欄位（field）。"},{id:"11.4",chapter:"11",number:"11-4",text_en:"All the members of a record must be ________.",text_zh:"記錄的所有成員必須是 ________。",options:[{key:"a",text_en:"character type",text_zh:"字元類型"},{key:"b",text_en:"related types",text_zh:"相關類型"},{key:"c",text_en:"integer type",text_zh:"整數類型"},{key:"d",text_en:"the same type",text_zh:"相同類型"}],answer:"b",explanation_zh:"記錄中的欄位可以是不同的資料類型（例如，一個學生記錄可以包含字串類型的姓名和整數類型的年齡），但它們在邏輯上是相關的，共同描述一個實體。"},{id:"11.5",chapter:"11",number:"11-5",text_en:"________ is an ordered collection of data in which each element contains the location of the next element.",text_zh:"________ 是一個有序的資料集合，其中每個元素包含下一個元素的位置。",options:[{key:"a",text_en:"A file",text_zh:"檔案"},{key:"b",text_en:"A record",text_zh:"記錄"},{key:"c",text_en:"A linked list",text_zh:"鏈結串列"},{key:"d",text_en:"An array",text_zh:"陣列"}],answer:"c",explanation_zh:"鏈結串列（Linked list）是一種線性資料結構，其元素不儲存在連續的記憶體位置，而是透過每個元素中的指標（或連結）來指向下一個元素。"},{id:"11.6",chapter:"11",number:"11-6",text_en:"In a linked list, each element contains ________.",text_zh:"在鏈結串列中，每個元素包含 ________。",options:[{key:"a",text_en:"data and a link",text_zh:"資料和一個連結"},{key:"b",text_en:"only a link",text_zh:"僅一個連結"},{key:"c",text_en:"neither data nor a link",text_zh:"既沒有資料也沒有連結"},{key:"d",text_en:"only data",text_zh:"僅資料"}],answer:"a",explanation_zh:"鏈結串列中的每個元素，通常稱為節點（node），包含兩個部分：儲存的資料（data）和指向下一個節點的連結（link）或指標（pointer）。"},{id:"11.7",chapter:"11",number:"11-7",text_en:"The ________ is a pointer that identifies the next element in the linked list.",text_zh:"________ 是一個識別鏈結串列中下一個元素的指標。",options:[{key:"a",text_en:"data",text_zh:"資料"},{key:"b",text_en:"node",text_zh:"節點"},{key:"c",text_en:"array",text_zh:"陣列"},{key:"d",text_en:"link",text_zh:"連結"}],answer:"d",explanation_zh:"在節點中，連結（link）部分儲存了下一個節點的記憶體位址，它就像一個指向下一個元素的指標。"},{id:"11.8",chapter:"11",number:"11-8",text_en:"Given a linked list called children, the pointer variable children identifies ________ element of the linked list.",text_zh:"給定一個名為 children 的鏈結串列，指標變數 children 識別鏈結串列的 ________ 元素。",options:[{key:"a",text_en:"the last",text_zh:"最後一個"},{key:"b",text_en:"the second",text_zh:"第二個"},{key:"c",text_en:"any",text_zh:"任何一個"},{key:"d",text_en:"the first",text_zh:"第一個"}],answer:"d",explanation_zh:"通常，一個指向鏈結串列的指標變數（稱為頭指標，head pointer）儲存的是串列中第一個節點的位址。"},{id:"11.9",chapter:"11",number:"11-9",text_en:"An empty linked list consists of ________.",text_zh:"一個空的鏈結串列包含 ________。",options:[{key:"a",text_en:"a null head pointer",text_zh:"一個空頭指標"},{key:"b",text_en:"two nodes",text_zh:"兩個節點"},{key:"c",text_en:"data and a link",text_zh:"資料和一個連結"},{key:"d",text_en:"a node",text_zh:"一個節點"}],answer:"a",explanation_zh:"如果一個鏈結串列是空的（不包含任何節點），那麼它的頭指標將會是一個空指標（null pointer）。"},{id:"11.10",chapter:"11",number:"11-10",text_en:"To traverse a list, you need a ________ pointer.",text_zh:"要遍歷一個串列，你需要一個 ________ 指標。",options:[{key:"a",text_en:"insertion",text_zh:"插入"},{key:"b",text_en:"walking",text_zh:"行走"},{key:"c",text_en:"beginning",text_zh:"起始"},{key:"d",text_en:"null",text_zh:"空"}],answer:"b",explanation_zh:"遍歷（traverse）鏈結串列是指從頭到尾訪問每個節點。通常會使用一個額外的「行走」指標（walking/traversing pointer），從頭指標開始，依次移動到下一個節點，直到到達串列的末尾。"}],z=[{id:"12.1",chapter:"12",number:"12-1",text_en:"In an abstract data type, ________.",text_zh:"在抽象資料型別中，________。",options:[{key:"a",text_en:"Nothing is hidden",text_zh:"沒有任何東西被隱藏"},{key:"b",text_en:"the ADT implementation is hidden",text_zh:"ADT 的實作是隱藏的"},{key:"c",text_en:"the ADT implementation is known",text_zh:"ADT 的實作是已知的"},{key:"d",text_en:"the ADT public operations are hidden",text_zh:"ADT 的公開操作是隱藏的"}],answer:"b",explanation_zh:"抽象資料型別（Abstract Data Type, ADT）的核心思想是資訊隱藏（information hiding）。它只定義了資料的邏輯特性和操作介面，而將其底層的具體實作細節隱藏起來。"},{id:"12.2",chapter:"12",number:"12-2",text_en:"A stack is a ________ structure.",text_zh:"堆疊是 ________ 結構。",options:[{key:"a",text_en:"SIFO",text_zh:"SIFO"},{key:"b",text_en:"LIFO",text_zh:"後進先出"},{key:"c",text_en:"FIFO",text_zh:"先進先出"},{key:"d",text_en:"DIFO",text_zh:"DIFO"}],answer:"b",explanation_zh:"堆疊（Stack）是一種後進先出（Last-In, First-Out, LIFO）的資料結構。最後被放入堆疊的元素會是第一個被取出的。"},{id:"12.3",chapter:"12",number:"12-3",text_en:"A(n) ________ list is also known as a queue.",text_zh:"________ 列表也稱為佇列。",options:[{key:"a",text_en:"ordered",text_zh:"有序"},{key:"b",text_en:"FIFO",text_zh:"先進先出"},{key:"c",text_en:"LIFO",text_zh:"後進先出"},{key:"d",text_en:"unordered",text_zh:"無序"}],answer:"b",explanation_zh:"佇列（Queue）是一種先進先出（First-In, First-Out, FIFO）的資料結構。最早被放入佇列的元素會是第一個被取出的。"},{id:"12.4",chapter:"12",number:"12-4",text_en:"If A is the first data element input into a stack, followed by B, C, and D, then ________ is the first element to be removed.",text_zh:"如果 A 是第一個輸入到堆疊的資料元素，接著是 B、C 和 D，那麼 ________ 是第一個被移除的元素。",options:[{key:"a",text_en:"D",text_zh:"D"},{key:"b",text_en:"B",text_zh:"B"},{key:"c",text_en:"A",text_zh:"A"},{key:"d",text_en:"C",text_zh:"C"}],answer:"a",explanation_zh:"堆疊是後進先出（LIFO）。輸入順序是 A, B, C, D。D 是最後一個進入的，所以它會是第一個被移除的。"},{id:"12.5",chapter:"12",number:"12-5",text_en:"If A is the first data element input into a queue, followed by B, C, and D, then ________ is the first element to be removed.",text_zh:"如果 A 是第一個輸入到佇列的資料元素，接著是 B、C 和 D，那麼 ________ 是第一個被移除的元素。",options:[{key:"a",text_en:"D",text_zh:"D"},{key:"b",text_en:"B",text_zh:"B"},{key:"c",text_en:"A",text_zh:"A"},{key:"d",text_en:"C",text_zh:"C"}],answer:"c",explanation_zh:"佇列是先進先出（FIFO）。輸入順序是 A, B, C, D。A 是第一個進入的，所以它會是第一個被移除的。"},{id:"12.6",chapter:"12",number:"12-6",text_en:"The pop operation ________ of the stack.",text_zh:"pop 操作 ________ 堆疊。",options:[{key:"a",text_en:"inserts an item at the bottom",text_zh:"在底部插入一個項目"},{key:"b",text_en:"deletes an item from the bottom",text_zh:"從底部刪除一個項目"},{key:"c",text_en:"deletes an item from the top",text_zh:"從頂部刪除一個項目"},{key:"d",text_en:"inserts an item at the top",text_zh:"在頂部插入一個項目"}],answer:"c",explanation_zh:"pop 操作是指從堆疊的頂部（top）移除並返回元素。"},{id:"12.7",chapter:"12",number:"12-7",text_en:"The push operation ________ of the stack.",text_zh:"push 操作 ________ 堆疊。",options:[{key:"a",text_en:"inserts an item at the bottom",text_zh:"在底部插入一個項目"},{key:"b",text_en:"deletes an item from the bottom",text_zh:"從底部刪除一個項目"},{key:"c",text_en:"deletes an item from the top",text_zh:"從頂部刪除一個項目"},{key:"d",text_en:"inserts an item at the top",text_zh:"在頂部插入一個項目"}],answer:"d",explanation_zh:"push 操作是指將一個元素添加到堆疊的頂部（top）。"},{id:"12.8",chapter:"12",number:"12-8",text_en:"In a binary tree, each node has ________ two subtrees.",text_zh:"在二元樹中，每個節點最多有 ________ 兩個子樹。",options:[{key:"a",text_en:"at least",text_zh:"至少"},{key:"b",text_en:"less than",text_zh:"少於"},{key:"c",text_en:"more than",text_zh:"多於"},{key:"d",text_en:"at most",text_zh:"最多"}],answer:"d",explanation_zh:"根據定義，二元樹（Binary Tree）中的每個節點最多只能有兩個子節點（稱為左子節點和右子節點），也就是說，子節點的數量可以是 0、1 或 2。"},{id:"12.9",chapter:"12",number:"12-9",text_en:"In preorder traversal of a binary tree, the ________.",text_zh:"在二元樹的前序遍歷中，________。",options:[{key:"a",text_en:"the root is never processed",text_zh:"根節點永不處理"},{key:"b",text_en:"right subtree is processed first",text_zh:"先處理右子樹"},{key:"c",text_en:"left subtree is processed first",text_zh:"先處理左子樹"},{key:"d",text_en:"root is processed first",text_zh:"先處理根節點"}],answer:"d",explanation_zh:"前序遍歷（Preorder traversal）的順序是：根節點 -> 左子樹 -> 右子樹。因此，根節點總是第一個被處理。"},{id:"12.10",chapter:"12",number:"12-10",text_en:"In ________ traversal of a binary tree, the right subtree is processed last.",text_zh:"在二元樹的 ________ 遍歷中，右子樹是最後被處理的。",options:[{key:"a",text_en:"any order",text_zh:"任何順序"},{key:"b",text_en:"inorder",text_zh:"中序"},{key:"c",text_en:"preorder",text_zh:"前序"},{key:"d",text_en:"postorder",text_zh:"後序"}],answer:"b",explanation_zh:"中序遍歷（Inorder traversal）的順序是：左子樹 -> 根節點 -> 右子樹。因此，右子樹在左子樹和根節點之後處理。"},{id:"12.11",chapter:"12",number:"12-11",text_en:"In postorder traversal of a binary tree, the root is processed ________.",text_zh:"在二元樹的後序遍歷中，根節點是 ________ 被處理的。",options:[{key:"a",text_en:"after the left subtree",text_zh:"在左子樹之後"},{key:"b",text_en:"second",text_zh:"第二個"},{key:"c",text_en:"first",text_zh:"第一個"},{key:"d",text_en:"last",text_zh:"最後一個"}],answer:"d",explanation_zh:"後序遍歷（Postorder traversal）的順序是：左子樹 -> 右子樹 -> 根節點。因此，根節點總是在其所有子節點都被處理完之後，最後一個被處理。"},{id:"12.12",chapter:"12",number:"12-12",text_en:"In postorder traversal of a binary tree, the left subtree is processed ________.",text_zh:"在二元樹的後序遍歷中，左子樹是 ________ 被處理的。",options:[{key:"a",text_en:"after the right subtree",text_zh:"在右子樹之後"},{key:"b",text_en:"second",text_zh:"第二個"},{key:"c",text_en:"first",text_zh:"第一個"},{key:"d",text_en:"last",text_zh:"最後一個"}],answer:"c",explanation_zh:"後序遍歷（Postorder traversal）的順序是：左子樹 -> 右子樹 -> 根節點。因此，左子樹是第一個被處理的。"},{id:"12.13",chapter:"12",number:"12-13",text_en:"In ________ traversal of a binary tree, the left subtree is processed last.",text_zh:"在二元樹的 ________ 遍歷中，左子樹是最後被處理的。",options:[{key:"a",text_en:"out of order",text_zh:"亂序"},{key:"b",text_en:"inorder",text_zh:"中序"},{key:"c",text_en:"preorder",text_zh:"前序"},{key:"d",text_en:"postorder",text_zh:"後序"}],answer:"c",explanation_zh:"這個問題存在錯誤。在標準的前序、中序、後序遍歷中，左子樹總是在右子樹之前被處理。沒有一種標準遍歷是最後處理左子樹的。鑒於提供的答案是 c，這可能是一個錯誤的題目。"},{id:"12.14",chapter:"12",number:"12-14",text_en:"In an inorder traversal of a binary tree, the root is processed ________.",text_zh:"在二元樹的中序遍歷中，根節點是 ________ 被處理的。",options:[{key:"a",text_en:"two times",text_zh:"兩次"},{key:"b",text_en:"second",text_zh:"第二個"},{key:"c",text_en:"first",text_zh:"第一個"},{key:"d",text_en:"last",text_zh:"最後一個"}],answer:"b",explanation_zh:"中序遍歷（Inorder traversal）的順序是：左子樹 -> 根節點 -> 右子樹。因此，根節點在左子樹之後、右子樹之前被處理，是第二個被處理的部分。"}],c=[{id:"13.1",chapter:"13",number:"13-1",text_en:"________ file can be accessed randomly.",text_zh:"________ 檔案可以隨機存取。",options:[{key:"a",text_en:"A sequential",text_zh:"循序"},{key:"b",text_en:"A hashed",text_zh:"雜湊"},{key:"c",text_en:"An indexed",text_zh:"索引"},{key:"d",text_en:"Any",text_zh:"任何"}],answer:"d",explanation_zh:"此題答案有爭議。嚴格來說，只有索引檔（indexed）和雜湊檔（hashed）是為高效隨機存取而設計的。循序檔（sequential file）的隨機存取效率極低。選項 'Any' 可能是指理論上任何檔案都可以透過跳過記錄來模擬隨機存取，但這不是其設計目的。"},{id:"13.2",chapter:"13",number:"13-2",text_en:"________ file can be accessed sequentially.",text_zh:"________ 檔案可以循序存取。",options:[{key:"a",text_en:"A sequential",text_zh:"循序"},{key:"b",text_en:"A hashed",text_zh:"雜湊"},{key:"c",text_en:"An indexed",text_zh:"索引"},{key:"d",text_en:"No",text_zh:"無"}],answer:"a",explanation_zh:"循序檔（Sequential file）是按記錄的物理順序來組織的，因此最自然的存取方式就是從頭到尾循序讀取。"},{id:"13.3",chapter:"13",number:"13-3",text_en:"When a sequential file is updated, the ________ file gets the actual update.",text_zh:"當循序檔被更新時，________ 檔案會得到實際的更新。",options:[{key:"a",text_en:"new master",text_zh:"新主檔"},{key:"b",text_en:"transaction",text_zh:"交易檔"},{key:"c",text_en:"old master",text_zh:"舊主檔"},{key:"d",text_en:"error report",text_zh:"錯誤報告"}],answer:"a",explanation_zh:"循序檔的更新通常是透過讀取舊主檔和交易檔，然後將更新後的結果寫入一個全新的主檔（new master file）來完成的。"},{id:"13.4",chapter:"13",number:"13-4",text_en:"When a sequential file is updated, the ________ file contains a list of all errors occurring during the update process.",text_zh:"當循序檔被更新時，________ 檔案包含更新過程中發生的所有錯誤列表。",options:[{key:"a",text_en:"new master",text_zh:"新主檔"},{key:"b",text_en:"transaction",text_zh:"交易檔"},{key:"c",text_en:"old master",text_zh:"舊主檔"},{key:"d",text_en:"error report",text_zh:"錯誤報告"}],answer:"d",explanation_zh:"在檔案更新過程中，任何無效的交易（例如，試圖更新不存在的記錄）都會被記錄在錯誤報告（error report）檔案中。"},{id:"13.5",chapter:"13",number:"13-5",text_en:"When a sequential file is updated, the ________ file contains the changes to be applied.",text_zh:"當循序檔被更新時，________ 檔案包含要應用的變更。",options:[{key:"a",text_en:"new master",text_zh:"新主檔"},{key:"b",text_en:"transaction",text_zh:"交易檔"},{key:"c",text_en:"old master",text_zh:"舊主檔"},{key:"d",text_en:"error report",text_zh:"錯誤報告"}],answer:"b",explanation_zh:"交易檔（Transaction file）儲存了對主檔要進行的所有變更，例如新增、刪除或修改記錄。"},{id:"13.6",chapter:"13",number:"13-6",text_en:"After a sequential file is updated, the ________ file contains the most current data.",text_zh:"循序檔更新後，________ 檔案包含最新的資料。",options:[{key:"a",text_en:"new master",text_zh:"新主檔"},{key:"b",text_en:"transaction",text_zh:"交易檔"},{key:"c",text_en:"old master",text_zh:"舊主檔"},{key:"d",text_en:"error report",text_zh:"錯誤報告"}],answer:"a",explanation_zh:"更新過程完成後，新主檔（new master file）會包含舊主檔和交易檔合併後的最新、最完整的資料。"},{id:"13.7",chapter:"13",number:"13-7",text_en:"If the transaction file key is 20 and the first master file key is 25, then we ________.",text_zh:"如果交易檔鍵值為 20，而第一個主檔鍵值為 25，那麼我們 ________。",options:[{key:"a",text_en:"add the new record to the new master file",text_zh:"將新記錄添加到新主檔"},{key:"b",text_en:"delete the data",text_zh:"刪除資料"},{key:"c",text_en:"revise the contents of the old master file",text_zh:"修改舊主檔的內容"},{key:"d",text_en:"write the old master file record to the new master file",text_zh:"將舊主檔記錄寫入新主檔"}],answer:"a",explanation_zh:"在循序檔更新中，如果交易檔的鍵值小於當前主檔的鍵值，這通常意味著這是一筆要新增的記錄，應將其寫入新主檔。"},{id:"13.8",chapter:"13",number:"13-8",text_en:"If the transaction file key is 20 with a delete code and the master file key is 20, then we ________.",text_zh:"如果交易檔鍵值為 20 且帶有刪除碼，而主檔鍵值也為 20，那麼我們 ________。",options:[{key:"a",text_en:"add the transaction to the new master file",text_zh:"將交易添加到新主檔"},{key:"b",text_en:"delete the data",text_zh:"刪除資料"},{key:"c",text_en:"revise the contents of the old master file",text_zh:"修改舊主檔的內容"},{key:"d",text_en:"write the old master file record to the new master file",text_zh:"將舊主檔記錄寫入新主檔"}],answer:"b",explanation_zh:"如果交易檔和主檔的鍵值匹配，且交易是刪除操作，那麼我們就不會將該主檔記錄寫入新主檔，從而達到刪除的效果。"},{id:"13.9",chapter:"13",number:"13-9",text_en:"An indexed file consists of ________.",text_zh:"一個索引檔由 ________ 組成。",options:[{key:"a",text_en:"only a sequential data file",text_zh:"僅循序資料檔"},{key:"b",text_en:"only a random data file",text_zh:"僅隨機資料檔"},{key:"c",text_en:"only an index",text_zh:"僅索引"},{key:"d",text_en:"an index and random data file",text_zh:"一個索引和一個隨機資料檔"}],answer:"d",explanation_zh:"索引檔結構包含兩部分：一個資料檔（通常是隨機存取檔）和一個或多個索引（index）。索引儲存了記錄鍵值與其在資料檔中位置的對應關係。"},{id:"13.10",chapter:"13",number:"13-10",text_en:"The index of an indexed file has ________ fields.",text_zh:"索引檔的索引有 ________ 個欄位。",options:[{key:"a",text_en:"two",text_zh:"二"},{key:"b",text_en:"four",text_zh:"四"},{key:"c",text_en:"three",text_zh:"三"},{key:"d",text_en:"any number of",text_zh:"任意數量"}],answer:"a",explanation_zh:"最基本的索引包含兩個欄位：記錄的鍵值（key）和指向該記錄在資料檔中位置的指標或位址（pointer/address）。"},{id:"13.11",chapter:"13",number:"13-11",text_en:"In the ________ hashing method, selected digits are extracted from the key and used as the address.",text_zh:"在 ________ 雜湊法中，從鍵值中提取選定的數字並用作位址。",options:[{key:"a",text_en:"direct",text_zh:"直接"},{key:"b",text_en:"modulo division",text_zh:"除法取餘"},{key:"c",text_en:"division remainder",text_zh:"除法餘數"},{key:"d",text_en:"digit extraction",text_zh:"數位提取"}],answer:"d",explanation_zh:"數位提取法（Digit extraction）是一種雜湊函數，它從鍵值中選取特定位置的數位來組合成雜湊位址。"},{id:"13.12",chapter:"13",number:"13-12",text_en:"In the ________ hashing method, the key is divided by the file size, and the address is the remainder plus 1.",text_zh:"在 ________ 雜湊法中，將鍵值除以檔案大小，位址是餘數加 1。",options:[{key:"a",text_en:"direct",text_zh:"直接"},{key:"b",text_en:"division remainder",text_zh:"除法餘數"},{key:"c",text_en:"modulo division",text_zh:"除法取餘"},{key:"d",text_en:"digit extraction",text_zh:"數位提取"}],answer:"c",explanation_zh:"除法取餘法（Modulo division）是最常見的雜湊函數之一。它將鍵值 K 除以一個數 M（通常是檔案大小或一個質數），然後取其餘數作為雜湊位址。位址通常是 `K mod M`，範圍從 0 到 M-1。"},{id:"13.13",chapter:"13",number:"13-13",text_en:"In the ________ hashing method, there are no synonyms or collisions.",text_zh:"在 ________ 雜湊法中，沒有同義詞或碰撞。",options:[{key:"a",text_en:"direct",text_zh:"直接"},{key:"b",text_en:"division remainder",text_zh:"除法餘數"},{key:"c",text_en:"modulo division",text_zh:"除法取餘"},{key:"d",text_en:"digit extraction",text_zh:"數位提取"}],answer:"a",explanation_zh:"直接雜湊法（Direct hashing）將鍵值本身用作位址。這種方法只有在鍵值是連續且範圍不大的情況下才可行，但它可以保證每個鍵值對應唯一的位址，因此不會產生碰撞。"},{id:"13.14",chapter:"13",number:"13-14",text_en:"________ are keys that hash to the same location in the data file.",text_zh:"________ 是指雜湊到資料檔中相同位置的鍵值。",options:[{key:"a",text_en:"Collisions",text_zh:"碰撞"},{key:"b",text_en:"Synonyms",text_zh:"同義詞"},{key:"c",text_en:"Buckets",text_zh:"桶"},{key:"d",text_en:"Linked lists",text_zh:"鏈結串列"}],answer:"b",explanation_zh:"當兩個或多個不同的鍵值經過同一個雜湊函數計算後得到相同的雜湊位址時，這些鍵值被稱為同義詞（Synonyms）。"},{id:"13.15",chapter:"13",number:"13-15",text_en:"When a hashing algorithm produces an address for an insertion key and that address is already occupied, it is called a ________.",text_zh:"當雜湊演算法為一個插入鍵值產生的位址已經被佔用時，這稱為 ________。",options:[{key:"a",text_en:"collision",text_zh:"碰撞"},{key:"b",text_en:"synonym",text_zh:"同義詞"},{key:"c",text_en:"probe",text_zh:"探測"},{key:"d",text_en:"linked list",text_zh:"鏈結串列"}],answer:"a",explanation_zh:"碰撞（Collision）是指兩個不同的鍵值（即同義詞）被雜湊到同一個位址的情況。處理碰撞是雜湊技術中的一個重要課題。"},{id:"13.16",chapter:"13",number:"13-16",text_en:"The address produced by a hashing algorithm is the ________ address.",text_zh:"由雜湊演算法產生的位址是 ________ 位址。",options:[{key:"a",text_en:"probe",text_zh:"探測"},{key:"b",text_en:"collision",text_zh:"碰撞"},{key:"c",text_en:"synonym",text_zh:"同義詞"},{key:"d",text_en:"home",text_zh:"主"}],answer:"d",explanation_zh:"由雜湊函數直接計算出的初始位址被稱為主位址（home address）。"},{id:"13.17",chapter:"13",number:"13-17",text_en:"The ________ area is the file area that contains all the home addresses.",text_zh:"________ 區域是包含所有主位址的檔案區域。",options:[{key:"a",text_en:"probe",text_zh:"探測"},{key:"b",text_en:"hash",text_zh:"雜湊"},{key:"c",text_en:"linked",text_zh:"連結"},{key:"d",text_en:"prime",text_zh:"主要"}],answer:"d",explanation_zh:"主要區域（Prime area）是指檔案中用於存放記錄的主位址空間。當發生碰撞時，記錄可能會被存放到溢位區域（overflow area）。"},{id:"13.18",chapter:"13",number:"13-18",text_en:"In the ________ collision resolution method, we try to put data that cannot be placed in location 123 into location 124.",text_zh:"在 ________ 碰撞解決方法中，我們嘗試將無法放置在位置 123 的資料放入位置 124。",options:[{key:"a",text_en:"open addressing",text_zh:"開放定址"},{key:"b",text_en:"bucket hashing",text_zh:"桶雜湊"},{key:"c",text_en:"linked list",text_zh:"鏈結串列"},{key:"d",text_en:"random hashing",text_zh:"隨機雜湊"}],answer:"a",explanation_zh:"開放定址（Open addressing）是一種碰撞解決策略。當發生碰撞時，它會探測（probe）雜湊表中的其他位置，直到找到一個空槽來存放該記錄。線性探測（linear probing）就是其中最簡單的一種，即依次檢查下一個位置（如 124, 125, ...）。"}],p=[{id:"14.1",chapter:"14",number:"14-1",text_en:"In a three-level DBMS architecture, the layer that interacts directly with the hardware is the ________ level.",text_zh:"在三層 DBMS 架構中，直接與硬體互動的層是 ________ 層。",options:[{key:"a",text_en:"conceptual",text_zh:"概念 (conceptual)"},{key:"b",text_en:"physical",text_zh:"實體 (physical)"},{key:"c",text_en:"external",text_zh:"外部 (external)"},{key:"d",text_en:"internal",text_zh:"內部 (internal)"}],answer:"d",explanation_zh:"內部層級（Internal Level）負責資料在儲存裝置上的實際物理儲存細節，是直接與硬體互動的層級。"},{id:"14.2",chapter:"14",number:"14-2",text_en:"In a three-level DBMS architecture, the ________ level determines where data is actually stored on the storage devices.",text_zh:"在三層 DBMS 架構中，________ 層決定資料實際儲存在儲存設備上的位置。",options:[{key:"a",text_en:"conceptual",text_zh:"概念 (conceptual)"},{key:"b",text_en:"physical",text_zh:"實體 (physical)"},{key:"c",text_en:"external",text_zh:"外部 (external)"},{key:"d",text_en:"internal",text_zh:"內部 (internal)"}],answer:"d",explanation_zh:"內部層級決定了資料在實體儲存裝置上的具體配置和存取方法。"},{id:"14.3",chapter:"14",number:"14-3",text_en:"The ________ level of a three-level DBMS architecture defines the logical view of the data.",text_zh:"三層 DBMS 架構的 ________ 層定義了資料的邏輯視圖。",options:[{key:"a",text_en:"conceptual",text_zh:"概念 (conceptual)"},{key:"b",text_en:"physical",text_zh:"實體 (physical)"},{key:"c",text_en:"external",text_zh:"外部 (external)"},{key:"d",text_en:"internal",text_zh:"內部 (internal)"}],answer:"a",explanation_zh:"概念層級（Conceptual Level）代表資料庫的整體邏輯結構，獨立於實體儲存方式，是資料庫管理員看到的視圖。"},{id:"14.4",chapter:"14",number:"14-4",text_en:"The data model and the schema of a DBMS are often defined at the ________ level.",text_zh:"DBMS 的資料模型和架構通常在 ________ 層定義。",options:[{key:"a",text_en:"conceptual",text_zh:"概念 (conceptual)"},{key:"b",text_en:"physical",text_zh:"實體 (physical)"},{key:"c",text_en:"external",text_zh:"外部 (external)"},{key:"d",text_en:"internal",text_zh:"內部 (internal)"}],answer:"a",explanation_zh:"資料模型和整體架構（Schema）是在概念層級定義的，描述了資料之間的關係和約束。"},{id:"14.5",chapter:"14",number:"14-5",text_en:"In a three-level DBMS architecture, the ________ level interacts directly with the users.",text_zh:"在三層 DBMS 架構中，________ 層直接與使用者互動。",options:[{key:"a",text_en:"conceptual",text_zh:"概念 (conceptual)"},{key:"b",text_en:"physical",text_zh:"實體 (physical)"},{key:"c",text_en:"external",text_zh:"外部 (external)"},{key:"d",text_en:"internal",text_zh:"內部 (internal)"}],answer:"c",explanation_zh:"外部層級（External Level）也稱為使用者視圖，它提供給最終使用者或應用程式特定的資料視圖。"},{id:"14.6",chapter:"14",number:"14-6",text_en:"Of the various database models, the ________ model is the most prevalent today.",text_zh:"在各種資料庫模型中，________ 模型是當今最普遍的。",options:[{key:"a",text_en:"network",text_zh:"網路 (network)"},{key:"b",text_en:"linked list",text_zh:"鏈結串列 (linked list)"},{key:"c",text_en:"hierarchical",text_zh:"階層式 (hierarchical)"},{key:"d",text_en:"relational",text_zh:"關聯式 (relational)"}],answer:"d",explanation_zh:"關聯式資料庫模型（Relational Model）因為其嚴謹的數學基礎和靈活性，是目前最廣泛使用的資料庫模型。"},{id:"14.7",chapter:"14",number:"14-7",text_en:"Each column in a relation is called ________.",text_zh:"關聯中的每一列稱為 ________。",options:[{key:"a",text_en:"a tuple",text_zh:"元組 (tuple)"},{key:"b",text_en:"an attitude",text_zh:"態度"},{key:"c",text_en:"an attribute",text_zh:"屬性 (attribute)"},{key:"d",text_en:"a union",text_zh:"聯集"}],answer:"c",explanation_zh:"在關聯式資料庫中，表格的直列（column）代表資料的特徵，稱為屬性（Attribute）。"},{id:"14.8",chapter:"14",number:"14-8",text_en:"Each row in a relation is called ________.",text_zh:"關聯中的每一行稱為 ________。",options:[{key:"a",text_en:"a tuple",text_zh:"元組 (tuple)"},{key:"b",text_en:"an attitude",text_zh:"態度"},{key:"c",text_en:"an attribute",text_zh:"屬性 (attribute)"},{key:"d",text_en:"a union",text_zh:"聯集"}],answer:"a",explanation_zh:"在關聯式資料庫中，表格的橫行（row）代表一筆記錄，稱為元組（Tuple）。"},{id:"14.9",chapter:"14",number:"14-9",text_en:"A unary operator is applied to ________ relation(s) and creates an output of ________ relation(s).",text_zh:"一元運算子應用於 ________ 個關聯並產生 ________ 個關聯的輸出。",options:[{key:"a",text_en:"one, two",text_zh:"一，二"},{key:"b",text_en:"two, two",text_zh:"二，二"},{key:"c",text_en:"one, one",text_zh:"一，一"},{key:"d",text_en:"two, one",text_zh:"二，一"}],answer:"c",explanation_zh:"一元運算子（如選擇 Select、投影 Project）作用於單一個關聯表，並產生一個新的結果關聯表。"},{id:"14.10",chapter:"14",number:"14-10",text_en:"A binary operator is applied to ________ relation(s) and creates an output of ________ relation(s).",text_zh:"二元運算子應用於 ________ 個關聯並產生 ________ 個關聯的輸出。",options:[{key:"a",text_en:"one, two",text_zh:"一，二"},{key:"b",text_en:"two, two",text_zh:"二，二"},{key:"c",text_en:"one, one",text_zh:"一，一"},{key:"d",text_en:"two, one",text_zh:"二，一"}],answer:"d",explanation_zh:"二元運算子（如連接 Join、聯集 Union）作用於兩個關聯表，並產生一個新的結果關聯表。"},{id:"14.11",chapter:"14",number:"14-11",text_en:"The unary ________ operation always results in a relation that has exactly one more row than the original relation.",text_zh:"一元 ________ 操作總是導致一個比原始關聯多一行的關聯。",options:[{key:"a",text_en:"delete",text_zh:"刪除 (delete)"},{key:"b",text_en:"select",text_zh:"選擇 (select)"},{key:"c",text_en:"insert",text_zh:"插入 (insert)"},{key:"d",text_en:"update",text_zh:"更新 (update)"}],answer:"c",explanation_zh:"插入（Insert）操作會向關聯中新增一筆記錄（元組），因此行數會增加一。"},{id:"14.12",chapter:"14",number:"14-12",text_en:"If you want to change the value of an attribute of a tuple, you use the ________ operation.",text_zh:"如果你想改變元組屬性的值，你使用 ________ 操作。",options:[{key:"a",text_en:"join",text_zh:"連接 (join)"},{key:"b",text_en:"select",text_zh:"選擇 (select)"},{key:"c",text_en:"project",text_zh:"投影 (project)"},{key:"d",text_en:"update",text_zh:"更新 (update)"}],answer:"d",explanation_zh:"更新（Update）操作用於修改現有記錄中的資料值。"},{id:"14.13",chapter:"14",number:"14-13",text_en:"The operation that takes two relations and combines them based on common attributes is the ________ operation.",text_zh:"獲取兩個關聯並基於共同屬性將它們組合起來的操作是 ________ 操作。",options:[{key:"a",text_en:"project",text_zh:"投影 (project)"},{key:"b",text_en:"intersection",text_zh:"交集 (intersection)"},{key:"c",text_en:"join",text_zh:"連接 (join)"},{key:"d",text_en:"union",text_zh:"聯集 (union)"}],answer:"c",explanation_zh:"連接（Join）操作是關聯式資料庫中最強大的功能之一，它根據共同的欄位將兩個表的資料合併起來。"},{id:"14.14",chapter:"14",number:"14-14",text_en:"If you need to delete an attribute in a relation, you can use the ________ operation.",text_zh:"如果你需要刪除關聯中的一個屬性，你可以使用 ________ 操作。",options:[{key:"a",text_en:"project",text_zh:"投影 (project)"},{key:"b",text_en:"intersection",text_zh:"交集 (intersection)"},{key:"c",text_en:"join",text_zh:"連接 (join)"},{key:"d",text_en:"union",text_zh:"聯集 (union)"}],answer:"a",explanation_zh:"投影（Project）操作用於選擇關聯中的特定欄位（屬性）。通過選擇不想刪除的欄位，實際上就過濾掉了未被選擇的屬性（即刪除）。"},{id:"14.15",chapter:"14",number:"14-15",text_en:"You want to create a relation called New that contains tuples that belong to both relation A and relation B. For this, you can use the ________ operation.",text_zh:"你想創建一個名為 New 的關聯，其中包含同時屬於關聯 A 和關聯 B 的元組。為此，你可以使用 ________ 操作。",options:[{key:"a",text_en:"union",text_zh:"聯集 (union)"},{key:"b",text_en:"intersection",text_zh:"交集 (intersection)"},{key:"c",text_en:"select",text_zh:"選擇 (select)"},{key:"d",text_en:"project",text_zh:"投影 (project)"}],answer:"b",explanation_zh:"交集（Intersection）操作返回兩個集合中共有的元素。"},{id:"14.16",chapter:"14",number:"14-16",text_en:"Which of the following is a unary operator?",text_zh:"以下哪個是一元運算子？",options:[{key:"a",text_en:"union",text_zh:"聯集 (union)"},{key:"b",text_en:"project",text_zh:"投影 (project)"},{key:"c",text_en:"intersection",text_zh:"交集 (intersection)"},{key:"d",text_en:"join",text_zh:"連接 (join)"}],answer:"b",explanation_zh:"投影（Project）只作用於一個關聯表，因此是一元運算子。聯集、交集和連接都需要兩個表。"},{id:"14.17",chapter:"14",number:"14-17",text_en:"Which of the following is a binary operator?",text_zh:"以下哪個是二元運算子？",options:[{key:"a",text_en:"select",text_zh:"選擇 (select)"},{key:"b",text_en:"update",text_zh:"更新 (update)"},{key:"c",text_en:"difference",text_zh:"差集 (difference)"},{key:"d",text_en:"all of the above",text_zh:"以上皆是"}],answer:"c",explanation_zh:"差集（Difference）操作需要兩個關聯表（A - B），因此是二元運算子。選擇和更新通常作用於單個表。"},{id:"14.18",chapter:"14",number:"14-18",text_en:"________ is a declarative language used on relational databases.",text_zh:"________ 是一種用於關聯式資料庫的宣告式語言。",options:[{key:"a",text_en:"SQL",text_zh:"SQL"},{key:"b",text_en:"PBJ",text_zh:"PBJ"},{key:"c",text_en:"PDQ",text_zh:"PDQ"},{key:"d",text_en:"LES",text_zh:"LES"}],answer:"a",explanation_zh:"SQL（Structured Query Language）是關聯式資料庫的標準查詢語言，它是一種宣告式語言，使用者只需指定「要什麼」，而非「如何做」。"}],d=[{id:"15.1",chapter:"15",number:"15-1",text_en:"Data is compressed using a dictionary with indexes to strings. This is ________.",text_zh:"使用帶有字串索引的字典壓縮資料。這是 ________。",options:[{key:"a",text_en:"lossy coding",text_zh:"失真編碼"},{key:"b",text_en:"Huffman encoding",text_zh:"霍夫曼編碼"},{key:"c",text_en:"Lempel Ziv encoding",text_zh:"Lempel Ziv (LZ) 編碼"},{key:"d",text_en:"Morse coding",text_zh:"摩斯編碼"}],answer:"c",explanation_zh:"Lempel Ziv (LZ) 編碼是一種基於字典的壓縮方法，它將重複出現的字串儲存在字典中，並用索引代替。"},{id:"15.2",chapter:"15",number:"15-2",text_en:"A string of one hundred 0s is replaced by two markers, a 0, and the number 100. This is ________.",text_zh:"一百個 0 的字串被兩個標記、一個 0 和數字 100 取代。這是 ________。",options:[{key:"a",text_en:"Huffman encoding",text_zh:"霍夫曼編碼"},{key:"b",text_en:"Lempel Ziv encoding",text_zh:"Lempel Ziv 編碼"},{key:"c",text_en:"run-length encoding",text_zh:"連長編碼 (RLE)"},{key:"d",text_en:"Morse coding",text_zh:"摩斯編碼"}],answer:"c",explanation_zh:"連長編碼（Run-Length Encoding, RLE）將連續重複的資料值替換為該值和其重複次數，非常適合壓縮具有大量連續相同值的資料。"},{id:"15.3",chapter:"15",number:"15-3",text_en:"________ is an example of lossy compression.",text_zh:"________ 是失真壓縮的一個例子。",options:[{key:"a",text_en:"Run-length encoding",text_zh:"連長編碼"},{key:"b",text_en:"JPEG",text_zh:"JPEG"},{key:"c",text_en:"Huffman encoding",text_zh:"霍夫曼編碼"},{key:"d",text_en:"Lempel Ziv encoding",text_zh:"Lempel Ziv 編碼"}],answer:"b",explanation_zh:"JPEG 是一種用於圖像的失真壓縮標準，它透過丟棄人眼不敏感的資訊來減少檔案大小。RLE、Huffman 和 LZ 都是無損壓縮。"},{id:"15.4",chapter:"15",number:"15-4",text_en:"In a ________ data compression method, the received data is an exact copy of the original message.",text_zh:"在 ________ 資料壓縮方法中，接收到的資料是原始訊息的精確複本。",options:[{key:"a",text_en:"JPEG",text_zh:"JPEG"},{key:"b",text_en:"MPEG",text_zh:"MPEG"},{key:"c",text_en:"lossless",text_zh:"無損 (lossless)"},{key:"d",text_en:"lossy",text_zh:"失真 (lossy)"}],answer:"c",explanation_zh:"無損壓縮（Lossless Compression）保證解壓縮後的資料與原始資料完全一致，沒有任何資訊丟失。"},{id:"15.5",chapter:"15",number:"15-5",text_en:"________ data compression method, the received data need not be an exact copy of the original message.",text_zh:"________ 資料壓縮方法，接收到的資料不必是原始訊息的精確複本。",options:[{key:"a",text_en:"Only in MPEG",text_zh:"僅在 MPEG 中"},{key:"b",text_en:"In MP3, JPEG, or MPEG",text_zh:"在 MP3、JPEG 或 MPEG 中"},{key:"c",text_en:"Only in MP3",text_zh:"僅在 MP3 中"},{key:"d",text_en:"Only in JPEG",text_zh:"僅在 JPEG 中"}],answer:"b",explanation_zh:"MP3（音訊）、JPEG（圖像）和 MPEG（視訊）都是失真壓縮技術，它們通過捨棄部分細節來換取更高的壓縮率。"},{id:"15.6",chapter:"15",number:"15-6",text_en:"________ encoding is a lossless data compression method.",text_zh:"________ 編碼是一種無損資料壓縮方法。",options:[{key:"a",text_en:"Only LZ",text_zh:"僅 LZ"},{key:"b",text_en:"Huffman, run-length, or LZ",text_zh:"霍夫曼、連長或 LZ"},{key:"c",text_en:"Only Huffman",text_zh:"僅霍夫曼"},{key:"d",text_en:"Only Run-length",text_zh:"僅連長"}],answer:"b",explanation_zh:"霍夫曼編碼、連長編碼 (RLE) 和 Lempel Ziv (LZ) 都是常見的無損壓縮演算法。"},{id:"15.7",chapter:"15",number:"15-7",text_en:"In ________ encoding, the more frequently occurring characters have shorter codes than the less frequently occurring characters.",text_zh:"在 ________ 編碼中，出現頻率較高的字元比出現頻率較低的字元具有更短的代碼。",options:[{key:"a",text_en:"LZ",text_zh:"LZ"},{key:"b",text_en:"JPEG",text_zh:"JPEG"},{key:"c",text_en:"Huffman",text_zh:"霍夫曼 (Huffman)"},{key:"d",text_en:"run-length",text_zh:"連長"}],answer:"c",explanation_zh:"霍夫曼編碼利用字元出現的頻率來構建編碼樹，頻率高的字元分配較短的位元編碼，從而減少總位元數。"},{id:"15.8",chapter:"15",number:"15-8",text_en:"In ________ encoding, PPPPPPPPPPPPPPP can be replaced by P15.",text_zh:"在 ________ 編碼中，PPPPPPPPPPPPPPP 可以被 P15 取代。",options:[{key:"a",text_en:"LZ",text_zh:"LZ"},{key:"b",text_en:"MPEG",text_zh:"MPEG"},{key:"c",text_en:"Huffman",text_zh:"霍夫曼"},{key:"d",text_en:"run-length",text_zh:"連長 (run-length)"}],answer:"d",explanation_zh:"這是連長編碼 (RLE) 的典型應用，將重複的 'P' 替換為 'P' 及其重複次數 '15'。"},{id:"15.9",chapter:"15",number:"15-9",text_en:"LZ encoding requires ________.",text_zh:"LZ 編碼需要 ________。",options:[{key:"a",text_en:"only an algorithm",text_zh:"僅演算法"},{key:"b",text_en:"a dictionary, a buffer, and an algorithm",text_zh:"字典、緩衝區和演算法"},{key:"c",text_en:"only a dictionary",text_zh:"僅字典"},{key:"d",text_en:"only a buffer",text_zh:"僅緩衝區"}],answer:"b",explanation_zh:"LZ 編碼使用滑動視窗（緩衝區）和字典來查找和壓縮重複的字串模式。"},{id:"15.10",chapter:"15",number:"15-10",text_en:"JPEG encoding involves ________, a process that reveals the redundancies in a block.",text_zh:"JPEG 編碼涉及 ________，這是一個揭示區塊中冗餘的過程。",options:[{key:"a",text_en:"quantization",text_zh:"量化"},{key:"b",text_en:"vectorization",text_zh:"向量化"},{key:"c",text_en:"blocking",text_zh:"分塊"},{key:"d",text_en:"the discrete cosine transform",text_zh:"離散餘弦變換 (DCT)"}],answer:"d",explanation_zh:"離散餘弦變換 (DCT) 將圖像區塊從空間域轉換到頻率域，從而揭示其冗餘性，便於後續壓縮。"},{id:"15.11",chapter:"15",number:"15-11",text_en:"In JPEG encoding, the ________ process breaks the original picture into smaller blocks and assigns a value to each pixel in a block.",text_zh:"在 JPEG 編碼中，________ 過程將原始圖片分解為更小的區塊，並為區塊中的每個像素分配一個值。",options:[{key:"a",text_en:"quantization",text_zh:"量化"},{key:"b",text_en:"vectorization",text_zh:"向量化"},{key:"c",text_en:"blocking",text_zh:"分塊 (blocking)"},{key:"d",text_en:"DCT",text_zh:"DCT"}],answer:"c",explanation_zh:"分塊（Blocking）是 JPEG 編碼的第一步，通常將圖像分成 8x8 的像素塊進行處理。"},{id:"15.12",chapter:"15",number:"15-12",text_en:"The last step in JPEG, ________, removes redundancies.",text_zh:"JPEG 的最後一步，________，移除了冗餘。",options:[{key:"a",text_en:"compression",text_zh:"壓縮 (compression)"},{key:"b",text_en:"vectorization",text_zh:"向量化"},{key:"c",text_en:"blocking",text_zh:"分塊"},{key:"d",text_en:"quantization",text_zh:"量化"}],answer:"a",explanation_zh:"JPEG 的最後一步通常是使用無損壓縮算法（如霍夫曼編碼或 RLE）對量化後的數據進行編碼，進一步移除冗餘。"},{id:"15.13",chapter:"15",number:"15-13",text_en:"________ is a lossy compression method for pictures and graphics, whereas ________ is a lossy compression method for video.",text_zh:"________ 是一種用於圖片和圖形的失真壓縮方法，而 ________ 是一種用於視訊的失真壓縮方法。",options:[{key:"a",text_en:"JPEG, MPEG",text_zh:"JPEG, MPEG"},{key:"b",text_en:"JPEG, DCT",text_zh:"JPEG, DCT"},{key:"c",text_en:"DCT, MPEG",text_zh:"DCT, MPEG"},{key:"d",text_en:"MPEG, JPEG",text_zh:"MPEG, JPEG"}],answer:"a",explanation_zh:"JPEG 是靜態圖像的壓縮標準，而 MPEG 是動態視訊的壓縮標準。"}],y=[...e,...t,..._,...n,...a,...x,...o,...i,...h,...r,...s,...z,...c,...p,...d];export{y as problems};
