import type { Problem } from '../types';

export const problems: Problem[] = [
  {
    id: '4.1', chapter: '4', number: '4-1', isStarred: false,
    text_en: "________ is an arithmetic operation.",
    text_zh: "________ 是一種算術運算。",
    options: [
      { key: 'a', text_en: "The exclusive OR", text_zh: "互斥或" },
      { key: 'b', text_en: "Subtraction", text_zh: "減法" },
      { key: 'c', text_en: "The unary NOT", text_zh: "一元非" },
      { key: 'd', text_en: "The binary AND", text_zh: "二元與" },
    ],
    answer: 'b',
    explanation_zh: "減法（Subtraction）是一種基本的算術運算。AND、OR、XOR 和 NOT 則是邏輯運算。",
  },
  {
    id: '4.2', chapter: '4', number: '4-2', isStarred: false,
    text_en: "________ is a logical bit operator.",
    text_zh: "________ 是一種邏輯位元運算子。",
    options: [
      { key: 'a', text_en: "The exclusive OR", text_zh: "互斥或" },
      { key: 'b', text_en: "The binary AND", text_zh: "二元與" },
      { key: 'c', text_en: "The unary NOT", text_zh: "一元非" },
      { key: 'd', text_en: "exclusive OR, unary NOT, or binary AND", text_zh: "互斥或、一元非或二元與" },
    ],
    answer: 'd',
    explanation_zh: "邏輯位元運算子對二進位數的每一位進行操作。互斥或（XOR）、一元非（unary NOT）和二元與（binary AND）都屬於邏輯位元運算子。",
  },
  {
    id: '4.3', chapter: '4', number: '4-3', isStarred: false,
    text_en: "The ________ method of integer representation is the most common method for storing integers in computer memory.",
    text_zh: "________ 整數表示法是電腦記憶體中儲存整數最常見的方法。",
    options: [
      { key: 'a', text_en: "sign-and-magnitude", text_zh: "符號和數值" },
      { key: 'b', text_en: "two's complement", text_zh: "二的補數" },
      { key: 'c', text_en: "one's complement", text_zh: "一的補數" },
      { key: 'd', text_en: "unsigned integers", text_zh: "無符號整數" },
    ],
    answer: 'b',
    explanation_zh: "二的補數（two's complement）是電腦系統中最常用來表示和處理有符號整數的方法，因為它簡化了加法和減法運算。",
  },
  {
    id: '4.4', chapter: '4', number: '4-4', isStarred: false,
    text_en: "In two's complement addition, if there is a final carry after the left most column addition, ________.",
    text_zh: "在二的補數加法中，如果最左邊一欄相加後有最終進位，則 ________。",
    options: [
      { key: 'a', text_en: "add it to the right most column", text_zh: "將其加到最右邊一欄" },
      { key: 'b', text_en: "discard it", text_zh: "將其丟棄" },
      { key: 'c', text_en: "add it to the left most column", text_zh: "將其加到最左邊一欄" },
      { key: 'd', text_en: "increase the bit length", text_zh: "增加位元長度" },
    ],
    answer: 'b',
    explanation_zh: "在二的補數加法中，如果最高位（最左邊）相加產生了進位，這個進位應該被直接丟棄。這個特性使得加法和減法可以使用相同的電路來實現。",
  },
  {
    id: '4.5', chapter: '4', number: '4-5', isStarred: false,
    text_en: "For an 8-bit allocation, the smallest decimal number that can be represented in two's complement form is ________.",
    text_zh: "對於 8 位元的配置，可以用二的補數形式表示的最小十進位數是 ________。",
    options: [
      { key: 'a', text_en: "-8", text_zh: "-8" },
      { key: 'b', text_en: "-128", text_zh: "-128" },
      { key: 'c', text_en: "-127", text_zh: "-127" },
      { key: 'd', text_en: "-256", text_zh: "-256" },
    ],
    answer: 'b',
    explanation_zh: "對於 $n$ 位元的二的補數表示法，可表示的範圍是 $-2^{n-1}$ 到 $2^{n-1} - 1$。對於 8 位元，範圍是 $-2^7$ 到 $2^7 - 1$，即 $-128$ 到 $127$。最小數為 $-128$。",
  },
  {
    id: '4.6', chapter: '4', number: '4-6', isStarred: false,
    text_en: "For an 8-bit allocation, the largest decimal number that can be represented in two's complement form is ________.",
    text_zh: "對於 8 位元的配置，可以用二的補數形式表示的最大十進位數是 ________。",
    options: [
      { key: 'a', text_en: "8", text_zh: "8" },
      { key: 'b', text_en: "128", text_zh: "128" },
      { key: 'c', text_en: "127", text_zh: "127" },
      { key: 'd', text_en: "256", text_zh: "256" },
    ],
    answer: 'c',
    explanation_zh: "對於 $n$ 位元的二的補數表示法，可表示的範圍是 $-2^{n-1}$ 到 $2^{n-1} - 1$。對於 8 位元，範圍是 $-128$ 到 $127$。最大數為 $127$。",
  },
  {
    id: '4.7', chapter: '4', number: '4-7', isStarred: false,
    text_en: "In two's complement representation with a 4-bit allocation, we get ________ when we add 1 to 7.",
    text_zh: "在 4 位元配置的二的補數表示法中，當我們將 1 加到 7 時，得到 ________。",
    options: [
      { key: 'a', text_en: "8", text_zh: "8" },
      { key: 'b', text_en: "-7", text_zh: "-7" },
      { key: 'c', text_en: "1", text_zh: "1" },
      { key: 'd', text_en: "-8", text_zh: "-8" },
    ],
    answer: 'd',
    explanation_zh: "在 4 位元二的補數中，$7_{10} = 0111_2$。加 1 後為 $1000_2$。因為最高位是 1，這是一個負數。$1000_2$ 的二的補數是它本身，代表的十進位數是 $-8_{10}$。這是一個溢位（overflow）的例子。",
  },
  {
    id: '4.8', chapter: '4', number: '4-8', isStarred: false,
    text_en: "In two's complement representation with a 4-bit allocation, we get ________ when we add 5 to 5.",
    text_zh: "在 4 位元配置的二的補數表示法中，當我們將 5 加到 5 時，得到 ________。",
    options: [
      { key: 'a', text_en: "-5", text_zh: "-5" },
      { key: 'b', text_en: "-7", text_zh: "-7" },
      { key: 'c', text_en: "-6", text_zh: "-6" },
      { key: 'd', text_en: "10", text_zh: "10" },
    ],
    answer: 'c',
    explanation_zh: "在 4 位元二的補數中，$5_{10}$ 的表示為 $0101_2$。$5 + 5 = 10$，二進位相加為 $0101_2 + 0101_2 = 1010_2$。最高位是 1，為負數。取其二的補數得到 $0110_2$，即 6。所以 $1010_2$ 代表 $-6_{10}$。這也是一個溢位的例子。",
  },
  {
    id: '4.9', chapter: '4', number: '4-9', isStarred: false,
    text_en: "If the exponent in Excess_127 is binary 10000101, the exponent in decimal is ________.",
    text_zh: "如果 Excess_127 中的指數是二進位的 10000101，那麼十進位的指數是 ________。",
    options: [
      { key: 'a', text_en: "6", text_zh: "6" },
      { key: 'b', text_en: "8", text_zh: "8" },
      { key: 'c', text_en: "7", text_zh: "7" },
      { key: 'd', text_en: "9", text_zh: "9" },
    ],
    answer: 'a',
    explanation_zh: "在 Excess_127 表示法中，要得到真實的指數值，需要將二進位表示轉換為十進位後再減去偏置值 127。二進位 $10000101_2$ 等於十進位 $133_{10}$ ($128+4+1$)。所以真實指數是 $133 - 127 = 6$。",
  },
  {
    id: '4.10', chapter: '4', number: '4-10', isStarred: false,
    text_en: "If we are adding two numbers, one of which has an exponent value of 7 and the other an exponent value of 9, we need to shift the decimal point of the smaller number ________.",
    text_zh: "如果我們相加兩個數字，其中一個的指數值為 7，另一個的指數值為 9，我們需要將較小數字的小數點向 ________ 移動。",
    options: [
      { key: 'a', text_en: "one place to the left", text_zh: "左移一位" },
      { key: 'b', text_en: "two places to the left", text_zh: "左移兩位" },
      { key: 'c', text_en: "one place to the right", text_zh: "右移一位" },
      { key: 'd', text_en: "two places to the right", text_zh: "右移兩位" },
    ],
    answer: 'b',
    explanation_zh: "在進行浮點數加法時，需要先對齊指數。將指數較小的數的尾數向右移動，每移動一位，指數加一。為了將指數 7 對齊到 9，需要將指數為 7 的數的尾數向右移動 $9 - 7 = 2$ 位，這相當於將其小數點向左移動兩位。",
  },
  {
    id: '4.11', chapter: '4', number: '4-11', isStarred: false,
    text_en: "________ operator(s) takes two inputs to produce one output.",
    text_zh: "________ 運算子接受兩個輸入以產生一個輸出。",
    options: [
      { key: 'a', text_en: "Only AND", text_zh: "僅 AND" },
      { key: 'b', text_en: "Only XOR", text_zh: "僅 XOR" },
      { key: 'c', text_en: "Only OR", text_zh: "僅 OR" },
      { key: 'd', text_en: "AND, OR, or XOR", text_zh: "AND、OR 或 XOR" },
    ],
    answer: 'd',
    explanation_zh: "二元運算子（binary operator）接受兩個輸入（運算元）來產生一個輸出。AND, OR, XOR 都是二元運算子。NOT 是一元運算子。",
  },
  {
    id: '4.12', chapter: '4', number: '4-12', isStarred: false,
    text_en: "The unary ________ operator inverts its single input.",
    text_zh: "一元 ________ 運算子會反轉其單一輸入。",
    options: [
      { key: 'a', text_en: "AND", text_zh: "AND" },
      { key: 'b', text_en: "NOT", text_zh: "NOT" },
      { key: 'c', text_en: "OR", text_zh: "OR" },
      { key: 'd', text_en: "XOR", text_zh: "XOR" },
    ],
    answer: 'b',
    explanation_zh: "一元（unary）運算子只接受一個輸入。NOT 運算子（也稱為反相器）會將其輸入的位元反轉（0 變 1，1 變 0）。",
  },
  {
    id: '4.13', chapter: '4', number: '4-13', isStarred: false,
    text_en: "________ operator(s), if the input is two 0s, the output is 0.",
    text_zh: "________ 運算子，如果輸入是兩個 0，輸出是 0。",
    options: [
      { key: 'a', text_en: "In only AND", text_zh: "僅 AND" },
      { key: 'b', text_en: "In only XOR", text_zh: "僅 XOR" },
      { key: 'c', text_en: "In only OR", text_zh: "僅 OR" },
      { key: 'd', text_en: "In AND, OR, or XOR", text_zh: "在 AND、OR 或 XOR 中" },
    ],
    answer: 'd',
    explanation_zh: "AND: $0 \\& 0 = 0$. OR: $0 | 0 = 0$. XOR: $0 \\oplus 0 = 0$. 所以三者在輸入為兩個 0 時，輸出都是 0。",
  },
  {
    id: '4.14', chapter: '4', number: '4-14', isStarred: false,
    text_en: "________ operator(s), if the input is two 1s, the output is 0.",
    text_zh: "________ 運算子，如果輸入是兩個 1，輸出是 0。",
    options: [
      { key: 'a', text_en: "In only AND", text_zh: "僅 AND" },
      { key: 'b', text_en: "In only XOR", text_zh: "僅 XOR" },
      { key: 'c', text_en: "In only OR", text_zh: "僅 OR" },
      { key: 'd', text_en: "In AND, OR, or XOR", text_zh: "在 AND、OR 或 XOR 中" },
    ],
    answer: 'b',
    explanation_zh: "XOR (互斥或) 運算子的規則是：當兩個輸入位元不同時，輸出為 1；相同時，輸出為 0。因此當輸入是兩個 1 時，輸出是 0。",
  },
  {
    id: '4.15', chapter: '4', number: '4-15', isStarred: false,
    text_en: "For the binary AND operation, only an input of ________ gives an output of 1.",
    text_zh: "對於二進位 AND 運算，只有 ________ 的輸入會得到 1 的輸出。",
    options: [
      { key: 'a', text_en: "two 0s", text_zh: "兩個 0" },
      { key: 'b', text_en: "one 0 and one 1", text_zh: "一個 0 和一個 1" },
      { key: 'c', text_en: "two 1s", text_zh: "兩個 1" },
      { key: 'd', text_en: "two 2s", text_zh: "兩個 2" },
    ],
    answer: 'c',
    explanation_zh: "對於 AND 運算，只有當所有輸入都為 1 時，輸出才為 1。",
  },
  {
    id: '4.16', chapter: '4', number: '4-16', isStarred: false,
    text_en: "For the binary OR operation, only an input of ________ gives an output of 0.",
    text_zh: "對於二進位 OR 運算，只有 ________ 的輸入會得到 0 的輸出。",
    options: [
      { key: 'a', text_en: "two 0s", text_zh: "兩個 0" },
      { key: 'b', text_en: "one 0 and one 1", text_zh: "一個 0 和一個 1" },
      { key: 'c', text_en: "two 1s", text_zh: "兩個 1" },
      { key: 'd', text_en: "two 2s", text_zh: "兩個 2" },
    ],
    answer: 'a',
    explanation_zh: "對於 OR 運算，只有當所有輸入都為 0 時，輸出才為 0。",
  },
  {
    id: '4.17', chapter: '4', number: '4-17', isStarred: false,
    text_en: "We use a bit pattern called a ________ to modify another bit pattern.",
    text_zh: "我們使用稱為 ________ 的位元模式來修改另一個位元模式。",
    options: [
      { key: 'a', text_en: "mask", text_zh: "遮罩" },
      { key: 'b', text_en: "float", text_zh: "浮點數" },
      { key: 'c', text_en: "carry", text_zh: "進位" },
      { key: 'd', text_en: "byte", text_zh: "位元組" },
    ],
    answer: 'a',
    explanation_zh: "遮罩（mask）是一個位元模式，用於位元運算中，可以選擇性地修改、選取或清除另一個位元模式中的某些位元。",
  },
  {
    id: '4.18', chapter: '4', number: '4-18', isStarred: false,
    text_en: "To flip all the bits of a bit pattern, make a mask of all 1s and then ________ the bit pattern and the mask.",
    text_zh: "要反轉位元模式的所有位元，請建立一個全為 1 的遮罩，然後將該位元模式與遮罩進行 ________ 運算。",
    options: [
      { key: 'a', text_en: "AND", text_zh: "AND" },
      { key: 'b', text_en: "XOR", text_zh: "XOR" },
      { key: 'c', text_en: "OR", text_zh: "OR" },
      { key: 'd', text_en: "NOT", text_zh: "NOT" },
    ],
    answer: 'b',
    explanation_zh: "要反轉（flip）一個位元模式的所有位元，可以使用 XOR 運算。任何位元 A XOR 1 的結果都是 A 的反轉。因此，使用一個全為 1 的遮罩進行 XOR 運算可以反轉所有位元。",
  },
  {
    id: '4.19', chapter: '4', number: '4-19', isStarred: false,
    text_en: "To un-set (force to 0) all the bits of a bit pattern, make a mask of all 0s and then ________ the bit pattern and the mask.",
    text_zh: "要取消設定 (強制為 0) 位元模式的所有位元，請建立一個全為 0 的遮罩，然後將該位元模式與遮罩進行 ________ 運算。",
    options: [
      { key: 'a', text_en: "AND", text_zh: "AND" },
      { key: 'b', text_en: "XOR", text_zh: "XOR" },
      { key: 'c', text_en: "OR", text_zh: "OR" },
      { key: 'd', text_en: "NOT", text_zh: "NOT" },
    ],
    answer: 'a',
    explanation_zh: "要取消設定（un-set，強制為 0）一個位元模式中的某些位元，可以使用 AND 運算。任何位元 A AND 0 的結果都是 0。因此，使用一個全為 0 的遮罩進行 AND 運算可以將所有位元強制為 0。",
  },
  {
    id: '4.20', chapter: '4', number: '4-20', isStarred: false,
    text_en: "To set (force to 1) all the bits of a bit pattern, make a mask of all 1s and then ________ the bit pattern and the mask.",
    text_zh: "要設定 (強制為 1) 位元模式的所有位元，請建立一個全為 1 的遮罩，然後將該位元模式與遮罩進行 ________ 運算。",
    options: [
      { key: 'a', text_en: "AND", text_zh: "AND" },
      { key: 'b', text_en: "XOR", text_zh: "XOR" },
      { key: 'c', text_en: "OR", text_zh: "OR" },
      { key: 'd', text_en: "NOT", text_zh: "NOT" },
    ],
    answer: 'c',
    explanation_zh: "要設定（set，強制為 1）一個位元模式中的某些位元，可以使用 OR 運算。任何位元 A OR 1 的結果都是 1。因此，使用一個全為 1 的遮罩進行 OR 運算可以將所有位元強制為 1。",
  },
];
