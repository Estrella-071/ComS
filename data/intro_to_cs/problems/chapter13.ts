
import type { Problem } from '../../../types';

export const problems: Problem[] = [
  {
    id: '13.1', chapter: '14', number: '14-1',
    text_en: "________ file can be accessed randomly.",
    text_zh: "________ 檔案可以隨機存取。",
    options: [
      { key: 'a', text_en: "A sequential", text_zh: "循序" },
      { key: 'b', text_en: "A hashed", text_zh: "雜湊" },
      { key: 'c', text_en: "An indexed", text_zh: "索引" },
      { key: 'd', text_en: "Any", text_zh: "任何" },
    ],
    answer: 'd',
    explanation_zh: "此題答案有爭議。嚴格來說，只有索引檔（indexed）和雜湊檔（hashed）是為高效隨機存取而設計的。循序檔（sequential file）的隨機存取效率極低。選項 'Any' 可能是指理論上任何檔案都可以透過跳過記錄來模擬隨機存取，但這不是其設計目的。",
  },
  {
    id: '13.2', chapter: '14', number: '14-2',
    text_en: "________ file can be accessed sequentially.",
    text_zh: "________ 檔案可以循序存取。",
    options: [
      { key: 'a', text_en: "A sequential", text_zh: "循序" },
      { key: 'b', text_en: "A hashed", text_zh: "雜湊" },
      { key: 'c', text_en: "An indexed", text_zh: "索引" },
      { key: 'd', text_en: "No", text_zh: "無" },
    ],
    answer: 'a',
    explanation_zh: "循序檔（Sequential file）是按記錄的物理順序來組織的，因此最自然的存取方式就是從頭到尾循序讀取。",
  },
  {
    id: '13.3', chapter: '14', number: '14-3',
    text_en: "When a sequential file is updated, the ________ file gets the actual update.",
    text_zh: "當循序檔被更新時，________ 檔案會得到實際的更新。",
    options: [
      { key: 'a', text_en: "new master", text_zh: "新主檔" },
      { key: 'b', text_en: "transaction", text_zh: "交易檔" },
      { key: 'c', text_en: "old master", text_zh: "舊主檔" },
      { key: 'd', text_en: "error report", text_zh: "錯誤報告" },
    ],
    answer: 'a',
    explanation_zh: "循序檔的更新通常是透過讀取舊主檔和交易檔，然後將更新後的結果寫入一個全新的主檔（new master file）來完成的。",
  },
  {
    id: '13.4', chapter: '14', number: '14-4',
    text_en: "When a sequential file is updated, the ________ file contains a list of all errors occurring during the update process.",
    text_zh: "當循序檔被更新時，________ 檔案包含更新過程中發生的所有錯誤列表。",
    options: [
      { key: 'a', text_en: "new master", text_zh: "新主檔" },
      { key: 'b', text_en: "transaction", text_zh: "交易檔" },
      { key: 'c', text_en: "old master", text_zh: "舊主檔" },
      { key: 'd', text_en: "error report", text_zh: "錯誤報告" },
    ],
    answer: 'd',
    explanation_zh: "在檔案更新過程中，任何無效的交易（例如，試圖更新不存在的記錄）都會被記錄在錯誤報告（error report）檔案中。",
  },
  {
    id: '13.5', chapter: '14', number: '14-5',
    text_en: "When a sequential file is updated, the ________ file contains the changes to be applied.",
    text_zh: "當循序檔被更新時，________ 檔案包含要應用的變更。",
    options: [
      { key: 'a', text_en: "new master", text_zh: "新主檔" },
      { key: 'b', text_en: "transaction", text_zh: "交易檔" },
      { key: 'c', text_en: "old master", text_zh: "舊主檔" },
      { key: 'd', text_en: "error report", text_zh: "錯誤報告" },
    ],
    answer: 'b',
    explanation_zh: "交易檔（Transaction file）儲存了對主檔要進行的所有變更，例如新增、刪除或修改記錄。",
  },
  {
    id: '13.6', chapter: '14', number: '14-6',
    text_en: "After a sequential file is updated, the ________ file contains the most current data.",
    text_zh: "循序檔更新後，________ 檔案包含最新的資料。",
    options: [
      { key: 'a', text_en: "new master", text_zh: "新主檔" },
      { key: 'b', text_en: "transaction", text_zh: "交易檔" },
      { key: 'c', text_en: "old master", text_zh: "舊主檔" },
      { key: 'd', text_en: "error report", text_zh: "錯誤報告" },
    ],
    answer: 'a',
    explanation_zh: "更新過程完成後，新主檔（new master file）會包含舊主檔和交易檔合併後的最新、最完整的資料。",
  },
  {
    id: '13.7', chapter: '14', number: '14-7',
    text_en: "If the transaction file key is 20 and the first master file key is 25, then we ________.",
    text_zh: "如果交易檔鍵值為 20，而第一個主檔鍵值為 25，那麼我們 ________。",
    options: [
      { key: 'a', text_en: "add the new record to the new master file", text_zh: "將新記錄添加到新主檔" },
      { key: 'b', text_en: "delete the data", text_zh: "刪除資料" },
      { key: 'c', text_en: "revise the contents of the old master file", text_zh: "修改舊主檔的內容" },
      { key: 'd', text_en: "write the old master file record to the new master file", text_zh: "將舊主檔記錄寫入新主檔" },
    ],
    answer: 'a',
    explanation_zh: "在循序檔更新中，如果交易檔的鍵值小於當前主檔的鍵值，這通常意味著這是一筆要新增的記錄，應將其寫入新主檔。",
  },
  {
    id: '13.8', chapter: '14', number: '14-8',
    text_en: "If the transaction file key is 20 with a delete code and the master file key is 20, then we ________.",
    text_zh: "如果交易檔鍵值為 20 且帶有刪除碼，而主檔鍵值也為 20，那麼我們 ________。",
    options: [
      { key: 'a', text_en: "add the transaction to the new master file", text_zh: "將交易添加到新主檔" },
      { key: 'b', text_en: "delete the data", text_zh: "刪除資料" },
      { key: 'c', text_en: "revise the contents of the old master file", text_zh: "修改舊主檔的內容" },
      { key: 'd', text_en: "write the old master file record to the new master file", text_zh: "將舊主檔記錄寫入新主檔" },
    ],
    answer: 'b',
    explanation_zh: "如果交易檔和主檔的鍵值匹配，且交易是刪除操作，那麼我們就不會將該主檔記錄寫入新主檔，從而達到刪除的效果。",
  },
  {
    id: '13.9', chapter: '14', number: '14-9',
    text_en: "An indexed file consists of ________.",
    text_zh: "一個索引檔由 ________ 組成。",
    options: [
      { key: 'a', text_en: "only a sequential data file", text_zh: "僅循序資料檔" },
      { key: 'b', text_en: "only a random data file", text_zh: "僅隨機資料檔" },
      { key: 'c', text_en: "only an index", text_zh: "僅索引" },
      { key: 'd', text_en: "an index and random data file", text_zh: "一個索引和一個隨機資料檔" },
    ],
    answer: 'd',
    explanation_zh: "索引檔結構包含兩部分：一個資料檔（通常是隨機存取檔）和一個或多個索引（index）。索引儲存了記錄鍵值與其在資料檔中位置的對應關係。",
  },
  {
    id: '13.10', chapter: '14', number: '14-10',
    text_en: "The index of an indexed file has ________ fields.",
    text_zh: "索引檔的索引有 ________ 個欄位。",
    options: [
      { key: 'a', text_en: "two", text_zh: "二" },
      { key: 'b', text_en: "four", text_zh: "四" },
      { key: 'c', text_en: "three", text_zh: "三" },
      { key: 'd', text_en: "any number of", text_zh: "任意數量" },
    ],
    answer: 'a',
    explanation_zh: "最基本的索引包含兩個欄位：記錄的鍵值（key）和指向該記錄在資料檔中位置的指標或位址（pointer/address）。",
  },
  {
    id: '13.11', chapter: '14', number: '14-11',
    text_en: "In the ________ hashing method, selected digits are extracted from the key and used as the address.",
    text_zh: "在 ________ 雜湊法中，從鍵值中提取選定的數字並用作位址。",
    options: [
      { key: 'a', text_en: "direct", text_zh: "直接" },
      { key: 'b', text_en: "modulo division", text_zh: "除法取餘" },
      { key: 'c', text_en: "division remainder", text_zh: "除法餘數" },
      { key: 'd', text_en: "digit extraction", text_zh: "數位提取" },
    ],
    answer: 'd',
    explanation_zh: "數位提取法（Digit extraction）是一種雜湊函數，它從鍵值中選取特定位置的數位來組合成雜湊位址。",
  },
  {
    id: '13.12', chapter: '14', number: '14-12',
    text_en: "In the ________ hashing method, the key is divided by the file size, and the address is the remainder plus 1.",
    text_zh: "在 ________ 雜湊法中，將鍵值除以檔案大小，位址是餘數加 1。",
    options: [
      { key: 'a', text_en: "direct", text_zh: "直接" },
      { key: 'b', text_en: "division remainder", text_zh: "除法餘數" },
      { key: 'c', text_en: "modulo division", text_zh: "除法取餘" },
      { key: 'd', text_en: "digit extraction", text_zh: "數位提取" },
    ],
    answer: 'c',
    explanation_zh: "除法取餘法（Modulo division）是最常見的雜湊函數之一。它將鍵值 K 除以一個數 M（通常是檔案大小或一個質數），然後取其餘數作為雜湊位址。位址通常是 `K mod M`，範圍從 0 到 M-1。",
  },
  {
    id: '13.13', chapter: '14', number: '14-13',
    text_en: "In the ________ hashing method, there are no synonyms or collisions.",
    text_zh: "在 ________ 雜湊法中，沒有同義詞或碰撞。",
    options: [
      { key: 'a', text_en: "direct", text_zh: "直接" },
      { key: 'b', text_en: "division remainder", text_zh: "除法餘數" },
      { key: 'c', text_en: "modulo division", text_zh: "除法取餘" },
      { key: 'd', text_en: "digit extraction", text_zh: "數位提取" },
    ],
    answer: 'a',
    explanation_zh: "直接雜湊法（Direct hashing）將鍵值本身用作位址。這種方法只有在鍵值是連續且範圍不大的情況下才可行，但它可以保證每個鍵值對應唯一的位址，因此不會產生碰撞。",
  },
  {
    id: '13.14', chapter: '14', number: '14-14',
    text_en: "________ are keys that hash to the same location in the data file.",
    text_zh: "________ 是指雜湊到資料檔中相同位置的鍵值。",
    options: [
      { key: 'a', text_en: "Collisions", text_zh: "碰撞" },
      { key: 'b', text_en: "Synonyms", text_zh: "同義詞" },
      { key: 'c', text_en: "Buckets", text_zh: "桶" },
      { key: 'd', text_en: "Linked lists", text_zh: "鏈結串列" },
    ],
    answer: 'b',
    explanation_zh: "當兩個或多個不同的鍵值經過同一個雜湊函數計算後得到相同的雜湊位址時，這些鍵值被稱為同義詞（Synonyms）。",
  },
  {
    id: '13.15', chapter: '14', number: '14-15',
    text_en: "When a hashing algorithm produces an address for an insertion key and that address is already occupied, it is called a ________.",
    text_zh: "當雜湊演算法為一個插入鍵值產生的位址已經被佔用時，這稱為 ________。",
    options: [
      { key: 'a', text_en: "collision", text_zh: "碰撞" },
      { key: 'b', text_en: "synonym", text_zh: "同義詞" },
      { key: 'c', text_en: "probe", text_zh: "探測" },
      { key: 'd', text_en: "linked list", text_zh: "鏈結串列" },
    ],
    answer: 'a',
    explanation_zh: "碰撞（Collision）是指兩個不同的鍵值（即同義詞）被雜湊到同一個位址的情況。處理碰撞是雜湊技術中的一個重要課題。",
  },
  {
    id: '13.16', chapter: '14', number: '14-16',
    text_en: "The address produced by a hashing algorithm is the ________ address.",
    text_zh: "由雜湊演算法產生的位址是 ________ 位址。",
    options: [
      { key: 'a', text_en: "probe", text_zh: "探測" },
      { key: 'b', text_en: "collision", text_zh: "碰撞" },
      { key: 'c', text_en: "synonym", text_zh: "同義詞" },
      { key: 'd', text_en: "home", text_zh: "主" },
    ],
    answer: 'd',
    explanation_zh: "由雜湊函數直接計算出的初始位址被稱為主位址（home address）。",
  },
  {
    id: '13.17', chapter: '14', number: '14-17',
    text_en: "The ________ area is the file area that contains all the home addresses.",
    text_zh: "________ 區域是包含所有主位址的檔案區域。",
    options: [
      { key: 'a', text_en: "probe", text_zh: "探測" },
      { key: 'b', text_en: "hash", text_zh: "雜湊" },
      { key: 'c', text_en: "linked", text_zh: "連結" },
      { key: 'd', text_en: "prime", text_zh: "主要" },
    ],
    answer: 'd',
    explanation_zh: "主要區域（Prime area）是指檔案中用於存放記錄的主位址空間。當發生碰撞時，記錄可能會被存放到溢位區域（overflow area）。",
  },
  {
    id: '13.18', chapter: '14', number: '14-18',
    text_en: "In the ________ collision resolution method, we try to put data that cannot be placed in location 123 into location 124.",
    text_zh: "在 ________ 碰撞解決方法中，我們嘗試將無法放置在位置 123 的資料放入位置 124。",
    options: [
      { key: 'a', text_en: "open addressing", text_zh: "開放定址" },
      { key: 'b', text_en: "bucket hashing", text_zh: "桶雜湊" },
      { key: 'c', text_en: "linked list", text_zh: "鏈結串列" },
      { key: 'd', text_en: "random hashing", text_zh: "隨機雜湊" },
    ],
    answer: 'a',
    explanation_zh: "開放定址（Open addressing）是一種碰撞解決策略。當發生碰撞時，它會探測（probe）雜湊表中的其他位置，直到找到一個空槽來存放該記錄。線性探測（linear probing）就是其中最簡單的一種，即依次檢查下一個位置（如 124, 125, ...）。",
  },
];
